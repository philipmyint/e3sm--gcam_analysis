window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "e3sm_extract_spatial_data_h0", "modulename": "e3sm_extract_spatial_data_h0", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "e3sm_extract_spatial_data_h0.process_inputs", "modulename": "e3sm_extract_spatial_data_h0", "qualname": "process_inputs", "kind": "function", "doc": "<p>Processes a dictionary of inputs (keys are options, values are choices for those options) for extracting spatial data from E3SM-generated NetCDF \nfiles and printing that data to smaller, focused NetCDF files that contain spatial data only for the variables specified in the dictionary.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>inputs:</strong>  Dictionary containing the user choice inputs for different options. This dictionary may be incomplete or have invalid values.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>List of dictionaries, where each dictionary has been processed so that it is complete in all options for a single focused NetCDF file.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "e3sm_extract_spatial_data_h0.process_dataset", "modulename": "e3sm_extract_spatial_data_h0", "qualname": "process_dataset", "kind": "function", "doc": "<p>Processes an xarray Dataset to add a total precipitation variable (including change units from m/s to mm/year) and \nadd a variable for the atmospheric mole fraction of CO2 in units of ppm.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>ds:</strong>  Dataset to process.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The processed Dataset.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ds</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "e3sm_extract_spatial_data_h0.extract_spatial_data_from_netcdf_files", "modulename": "e3sm_extract_spatial_data_h0", "qualname": "extract_spatial_data_from_netcdf_files", "kind": "function", "doc": "<p>Extracts time series data from E3SM-generated h0 NetCDF files of a particular type that are located in a simulation directory and puts this data \ninto a smaller, focused NetCDF file that contains annual-mean spatial data only for the variables specified by the user in the inputs dictionary.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>input:</strong>  Dictionary containing the user data-extraction inputs for different options. This dictionary is assumed to be complete (pre-processed).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "e3sm_extract_time_series_h0", "modulename": "e3sm_extract_time_series_h0", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "e3sm_extract_time_series_h0.process_dataframe", "modulename": "e3sm_extract_time_series_h0", "qualname": "process_dataframe", "kind": "function", "doc": "<p>Processes a Pandas DataFrame by adding new columns (e.g., total precipitation, mole fraction CO2) or changing the units (e.g., Pg instead of g). </p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df:</strong>  DataFrame to be processed.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The processed DataFrame.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "e3sm_extract_time_series_h0.extract_netcdf_file_into_dataframe", "modulename": "e3sm_extract_time_series_h0", "qualname": "extract_netcdf_file_into_dataframe", "kind": "function", "doc": "<p>Extracts the specified variables from an E3SM-generated NetCDF file into a Pandas DataFrame and performs the indicated lat/lon aggregation.\nEach NetCDF file contains simulation results for one month in a particular year from either EAM (atmosphere model) or ELM (land model). \nOne choice of aggregation type is to perform an area-weighted mean over the latitude/longitude coordinates for the given month.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>file:</strong>  Complete path and name of the NetCDF file.</li>\n<li><strong>variables:</strong>  List of variables that we want to extract from the NetCDF file.</li>\n<li><strong>lat_lon_aggregation_type:</strong>  String that indicates how we want to perform the aggregation over the lat/lon coordinates to form the time series.</li>\n<li><strong>region:</strong>  String for the region of interest. If not specified or not recognized, then there will be no restrictions on the lat/lon coordinates.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame containing one column for each of the variables, plus year and month columns.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file</span>, </span><span class=\"param\"><span class=\"n\">variables</span>, </span><span class=\"param\"><span class=\"n\">lat_lon_aggregation_type</span>, </span><span class=\"param\"><span class=\"n\">region</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "e3sm_extract_time_series_h0.extract_time_series_from_netcdf_files", "modulename": "e3sm_extract_time_series_h0", "qualname": "extract_time_series_from_netcdf_files", "kind": "function", "doc": "<p>Extracts time series data from E3SM-generated h0 NetCDF files in a simulation directory into a Pandas DataFrame and writes it to an output file. \nThe NetCDF files can be of more than one type (e.g., one set generated from the ELM model and another set from the EAM model in E3SM).\nEach NetCDF file contains simulation results for one month in a particular year.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>simulation_path:</strong>  Complete path of the directory containing the NetCDF output files from running a simulation.</li>\n<li><strong>output_file:</strong>  Name of the output file where the contents of the DataFrame will be written.</li>\n<li><strong>netcdf_substrings:</strong>  List where each element is itself a list of substrings. Each list corresponds to a particular type of NetCDF file and\nindicates the substrings that must be in the names of that NetCDF file type.</li>\n<li><strong>variables:</strong>  List where each element is itself a list of variables we want to extract for each type of NetCDF file. \nThe aggregate of all variables contained in these lists will together form the columns of the DataFrame.</li>\n<li><strong>lat_lon_aggregation_types:</strong>  List of strings that indicate what type of lat/lon aggregation we want to perform to produce the time series data \nfor each type of NetCDF file. Current options include 'area_weighted_mean_or_sum', 'mean', and 'sum'.</li>\n<li><strong>regions:</strong>  List of strings for the region of interest. If not specified or not recognized, then there will be no restrictions on the \nlat/lon coordinates (the entire globe will be used). </li>\n<li><strong>process_variables:</strong>  Boolean indicating if further processing is to be done on the outputs in the DataFrame. This includes adding new variables\nnot in the NetCDF files (e.g., total precipitation, mole fraction CO2) or changing the units (e.g., Pg instead of g).</li>\n<li><strong>start_year:</strong>  First year in the extracted time series data.</li>\n<li><strong>end_year:</strong>  Last year in the extracted time series data.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">simulation_path</span>,</span><span class=\"param\">\t<span class=\"n\">output_file</span>,</span><span class=\"param\">\t<span class=\"n\">netcdf_substrings</span>,</span><span class=\"param\">\t<span class=\"n\">variables</span>,</span><span class=\"param\">\t<span class=\"n\">lat_lon_aggregation_types</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">regions</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">process_variables</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">start_year</span><span class=\"o\">=</span><span class=\"mi\">2015</span>,</span><span class=\"param\">\t<span class=\"n\">end_year</span><span class=\"o\">=</span><span class=\"mi\">2100</span>,</span><span class=\"param\">\t<span class=\"n\">write_to_csv</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "e3sm_extract_time_series_surfdata_iesm_dyn", "modulename": "e3sm_extract_time_series_surfdata_iesm_dyn", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "e3sm_extract_time_series_surfdata_iesm_dyn.extract_dataframe_rows_for_given_year", "modulename": "e3sm_extract_time_series_surfdata_iesm_dyn", "qualname": "extract_dataframe_rows_for_given_year", "kind": "function", "doc": "<p>Processes the Pandas DataFrame so that it contains only the rows pertaining to the given year, where the year (or 'time') is a DataFrame index.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df:</strong>  DataFrame of interest.</li>\n<li><strong>year:</strong>  Year of interest.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame containing only the rows for the given year, with the 'time' column dropped.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">year</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "e3sm_extract_time_series_surfdata_iesm_dyn.extract_netcdf_file_into_dataframe_single_year", "modulename": "e3sm_extract_time_series_surfdata_iesm_dyn", "qualname": "extract_netcdf_file_into_dataframe_single_year", "kind": "function", "doc": "<p>For the given year, extracts the specified variables from the E3SM human component (EHC) land surface data file into a Pandas DataFrame. </p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>file:</strong>  NetCDF file generated by the EHC during run time. It contains data on land surface variables like harvest and grazing. </li>\n<li><strong>variables:</strong>  List of variables we want to extract from the NetCDF file. </li>\n<li><strong>region:</strong>  String for the region of interest. If not specified or not recognized, then there will be no restrictions on the lat/lon coordinates. </li>\n<li><strong>year:</strong>  Year of interest.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame containing one column for each of the variables, plus a column for the specific year of interest.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file</span>, </span><span class=\"param\"><span class=\"n\">variables</span>, </span><span class=\"param\"><span class=\"n\">region</span>, </span><span class=\"param\"><span class=\"n\">year</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "e3sm_extract_time_series_surfdata_iesm_dyn.extract_time_series_from_netcdf_file", "modulename": "e3sm_extract_time_series_surfdata_iesm_dyn", "qualname": "extract_time_series_from_netcdf_file", "kind": "function", "doc": "<p>Extracts the specified variables from an E3SM-generated NetCDF file into a Pandas DataFrame and performs the indicated operation on the variables.\nThis NetCDF file is generated dynamically during run time by the E3SM human component (EHC) and contains land surface data like harvest, grazing. </p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>inputs:</strong>  Dictionary containing the user choice inputs for different options, such as the variables that they want to extract from the file. </li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame containing one column for each of the variables, plus a column for the year.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "e3sm_plot_spatial_data", "modulename": "e3sm_plot_spatial_data", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "e3sm_plot_spatial_data.default_inputs_spatial_data", "modulename": "e3sm_plot_spatial_data", "qualname": "default_inputs_spatial_data", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;plot_directory&#x27;: &#x27;./&#x27;, &#x27;time_calculation&#x27;: &#x27;mean&#x27;, &#x27;plot_type_for_2_sets&#x27;: &#x27;absolute_difference&#x27;, &#x27;multiplier&#x27;: 1, &#x27;start_year&#x27;: 2071, &#x27;end_year&#x27;: 2090, &#x27;projection&#x27;: &lt;class &#x27;cartopy.crs.Robinson&#x27;&gt;, &#x27;cmap&#x27;: &#x27;bwr&#x27;, &#x27;width&#x27;: 10, &#x27;height&#x27;: 8, &#x27;cbar_on&#x27;: True, &#x27;cbar_label_size&#x27;: 20, &#x27;cbar_limits&#x27;: None, &#x27;cbar_x_offset&#x27;: 0.06, &#x27;title_size&#x27;: 24, &#x27;use_latex&#x27;: False, &#x27;produce_png&#x27;: False, &#x27;bbox_inches&#x27;: &#x27;tight&#x27;, &#x27;statistics_panel_size&#x27;: 14, &#x27;p_value_threshold&#x27;: 0.05, &#x27;p_value_file&#x27;: &#x27;p_values.dat&#x27;, &#x27;p_value_file_print_only_if_below_threshold&#x27;: True, &#x27;stippling_on&#x27;: False, &#x27;stippling_std_multiple&#x27;: 2, &#x27;stippling_hatches&#x27;: &#x27;xxxx&#x27;, &#x27;grid_file&#x27;: None}"}, {"fullname": "e3sm_plot_spatial_data.process_inputs", "modulename": "e3sm_plot_spatial_data", "qualname": "process_inputs", "kind": "function", "doc": "<p>Processes a dictionary of inputs (keys are options, values are choices for those options) for creating spatial plots from data in NetCDF files.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>inputs:</strong>  Dictionary containing the user plotting choice inputs for different options. This dictionary may be incomplete or have invalid values.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>List of dictionaries, each of which specifies completed plotting options for a single variable. If the user did not select a plotting option \n  for a particular variable, the default choice for that plotting option will be selected.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "e3sm_plot_spatial_data.plot_spatial_data_eam", "modulename": "e3sm_plot_spatial_data", "qualname": "plot_spatial_data_eam", "kind": "function", "doc": "<p>Creates spatial plots and perform statistical analysis for a single variable from E3SM EAM outputs. \nThe data for these spatial plots are stored in NetCDF files specified by the inputs dictionary.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>input:</strong>  Dictionary containing user inputs for different plotting options, where the keys are options and values are choices for those options.\nThis dictionary is assumed to be complete (pre-processed).</li>\n<li><strong>grid_file:</strong>  Path and name of the grid file for the EAM unstructured mesh.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span>, </span><span class=\"param\"><span class=\"n\">grid_file</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "e3sm_plot_spatial_data.plot_spatial_data_elm", "modulename": "e3sm_plot_spatial_data", "qualname": "plot_spatial_data_elm", "kind": "function", "doc": "<p>Creates spatial plots and perform statistical analysis for a single variable from E3SM ELM outputs. \nThe data for these spatial plots are stored in NetCDF files specified by the inputs dictionary.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>input:</strong>  Dictionary containing user inputs for different plotting options, where the keys are options and values are choices for those options.\nThis dictionary is assumed to be complete (pre-processed).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "e3sm_plot_spatial_data.plot_spatial_data_from_netcdf_files", "modulename": "e3sm_plot_spatial_data", "qualname": "plot_spatial_data_from_netcdf_files", "kind": "function", "doc": "<p>Parses a dictionary of inputs (keys are options, values are choices for those options) to create spatial plots for a single variable from either \nE3SM atmosphere (EAM) or land (ELM) outputs. The data for these spatial plots are stored in NetCDF files specified by the inputs dictionary.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>input:</strong>  Dictionary containing the user plotting choice inputs for different options. This dictionary is assumed to be complete (pre-processed).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "e3sm_plot_time_series", "modulename": "e3sm_plot_time_series", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "e3sm_plot_time_series.default_inputs_time_series", "modulename": "e3sm_plot_time_series", "qualname": "default_inputs_time_series", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;areas_in_thousands_km2&#x27;: True, &#x27;end_year&#x27;: 2100, &#x27;error_bars_alpha&#x27;: 0.2, &#x27;height&#x27;: 8, &#x27;include_annual_mean_across_all_sets&#x27;: False, &#x27;include_monthly_mean_across_all_sets&#x27;: False, &#x27;include_seasons&#x27;: {&#x27;MAM&#x27;: False, &#x27;JJA&#x27;: False, &#x27;SON&#x27;: False, &#x27;DJF&#x27;: False}, &#x27;legend_label_size&#x27;: 14, &#x27;legend_on&#x27;: True, &#x27;linestyle_tuples&#x27;: [(&#x27;solid&#x27;, (0, ())), (&#x27;dashed&#x27;, (0, (5, 5))), (&#x27;dotted&#x27;, (0, (1, 5))), (&#x27;dashdot&#x27;, (0, (3, 5, 1, 5))), (&#x27;loosely dotted&#x27;, (0, (1, 10))), (&#x27;loosely dashed&#x27;, (0, (5, 10))), (&#x27;densely dashed&#x27;, (0, (5, 1))), (&#x27;loosely dashdotted&#x27;, (0, (3, 10, 1, 10))), (&#x27;densely dashdotted&#x27;, (0, (3, 1, 1, 1))), (&#x27;dashdotdotted&#x27;, (0, (3, 5, 1, 5, 1, 5))), (&#x27;loosely dashdotdotted&#x27;, (0, (3, 10, 1, 10, 1, 10))), (&#x27;densely dashdotdotted&#x27;, (0, (3, 1, 1, 1, 1, 1)))], &#x27;linewidth&#x27;: 2, &#x27;monthly_aggregation_type&#x27;: &#x27;mean&#x27;, &#x27;monthly_time_series_plot&#x27;: False, &#x27;monthly_time_series_start_year&#x27;: 2071, &#x27;monthly_time_series_end_year&#x27;: 2090, &#x27;monthly_time_series_x_limits&#x27;: None, &#x27;monthly_time_series_y_limits&#x27;: None, &#x27;multiplier&#x27;: 1, &#x27;p_value_file&#x27;: &#x27;p_values.dat&#x27;, &#x27;p_value_file_print_only_if_below_threshold&#x27;: True, &#x27;p_value_marker&#x27;: &#x27;o&#x27;, &#x27;p_value_marker_size&#x27;: 6, &#x27;p_value_threshold&#x27;: 0.05, &#x27;plot_colors&#x27;: [&#x27;#1f77b4&#x27;, &#x27;#ff7f0e&#x27;, &#x27;#2ca02c&#x27;, &#x27;#d62728&#x27;, &#x27;#9467bd&#x27;, &#x27;#8c564b&#x27;, &#x27;#e377c2&#x27;, &#x27;#7f7f7f&#x27;, &#x27;#bcbd22&#x27;, &#x27;#17becf&#x27;, &#x27;#029386&#x27;, &#x27;#c20078&#x27;, &#x27;#53fca1&#x27;, &#x27;#fe01b1&#x27;, &#x27;#c65102&#x27;, &#x27;#fac205&#x27;, &#x27;#0b5509&#x27;, &#x27;#8a6e45&#x27;, &#x27;#fc5a50&#x27;, &#x27;#a2cffe&#x27;, &#x27;#ffb07c&#x27;], &#x27;plot_directory&#x27;: &#x27;./&#x27;, &#x27;plot_percent_difference&#x27;: False, &#x27;plot_type&#x27;: &#x27;ensemble_averages&#x27;, &#x27;produce_png&#x27;: False, &#x27;seasons_to_plot_separately&#x27;: {&#x27;MAM&#x27;: False, &#x27;JJA&#x27;: False, &#x27;SON&#x27;: False, &#x27;DJF&#x27;: False}, &#x27;start_year&#x27;: 2015, &#x27;std_annual_mean_across_all_sets_multiplier&#x27;: 1, &#x27;std_annual_multiplier&#x27;: 1, &#x27;std_monthly_mean_across_all_sets_multiplier&#x27;: 1, &#x27;std_monthly_multiplier&#x27;: 1, &#x27;std_seasons_multiplier&#x27;: None, &#x27;use_latex&#x27;: False, &#x27;width&#x27;: 10, &#x27;x_label_size&#x27;: 24, &#x27;x_limits&#x27;: None, &#x27;x_scale&#x27;: &#x27;linear&#x27;, &#x27;x_tick_label_size&#x27;: 20, &#x27;y_label_size&#x27;: 24, &#x27;y_limits&#x27;: None, &#x27;y_scale&#x27;: &#x27;linear&#x27;, &#x27;y_tick_label_size&#x27;: 20}"}, {"fullname": "e3sm_plot_time_series.process_inputs", "modulename": "e3sm_plot_time_series", "qualname": "process_inputs", "kind": "function", "doc": "<p>Processes a dictionary of inputs (keys are options, values are choices for those options) for creating time series plots.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>inputs:</strong>  Dictionary containing the user plotting choice inputs for different options. This dictionary may be incomplete or have invalid values.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>List of dictionaries, each of which specifies all plotting options for a single variable. If the user did not select a plotting option for\n  a particular variable, the default choice for that plotting option will be selected.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "e3sm_plot_time_series.plot_seasons", "modulename": "e3sm_plot_time_series", "qualname": "plot_seasons", "kind": "function", "doc": "<p>Adds seasons (as specified in the include_seasons dictionary) to a given time series plot. </p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>include_seasons:</strong>  Dictionary specifying the seasons to include in the plot.</li>\n<li><strong>ax:</strong>  Axis object for the plot.</li>\n<li><strong>df:</strong>  Pandas DataFrame containing the time series data.</li>\n<li><strong>x:</strong>  Years to put on the x-axis.</li>\n<li><strong>output_label:</strong>  Base output label.</li>\n<li><strong>plot_colors:</strong>  List of plot line colors.</li>\n<li><strong>linestyle_tuples:</strong>  Tuples for the linestyles.</li>\n<li><strong>linewidth:</strong>  Thickness of the lines.</li>\n<li><strong>columns:</strong>  String (if a single column) or list (multiple columns) for the datasets in the DataFrame that we want to plot. \nIf a list, plot the mean across all columns.</li>\n<li><strong>reference_data:</strong>  Dictionary to store the data from the first file or first file set, which will serve as the reference set for \npercent difference calculations.</li>\n<li><strong>file_or_file_set_index:</strong>  Index for the particular file or file set, so that we can flag whether the current data pertain to the reference set.</li>\n<li><strong>std_multiplier:</strong>  Multiplier on the standard deviation for plotting error bars.</li>\n<li><strong>error_bars_alpha:</strong>  Opacity value for the error bars.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The reference_data, which will be updated with entries for the reference data for each season if this dictionary was not initially empty.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">include_seasons</span>,</span><span class=\"param\">\t<span class=\"n\">ax</span>,</span><span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">x</span>,</span><span class=\"param\">\t<span class=\"n\">output_label</span>,</span><span class=\"param\">\t<span class=\"n\">plot_colors</span>,</span><span class=\"param\">\t<span class=\"n\">linestyle_tuples</span>,</span><span class=\"param\">\t<span class=\"n\">linewidth</span>,</span><span class=\"param\">\t<span class=\"n\">columns</span>,</span><span class=\"param\">\t<span class=\"n\">reference_data</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">file_or_file_set_index</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">std_multiplier</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">error_bars_alpha</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "e3sm_plot_time_series.read_file_into_single_variable_dataframe", "modulename": "e3sm_plot_time_series", "qualname": "read_file_into_single_variable_dataframe", "kind": "function", "doc": "<p>Reads a file and puts the time series data for one specific variable from that file into a Pandas DataFrame. </p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>file:</strong>  Directory and name for the file we want to read.</li>\n<li><strong>variable:</strong>  The variable of interest.</li>\n<li><strong>start_year:</strong>  First year in the extracted time series data.</li>\n<li><strong>end_year:</strong>  Last year in the extracted time series data.</li>\n<li><strong>multiplier:</strong>  Multiplier on the time series (in case the user wants to change the units).</li>\n<li><strong>return_column:</strong>  Boolean that specifies if we want to additionally return the column in the DataFrame corresponding to the variable.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame containing the data for the variable and also the column in the DataFrame for that variable if return_column is True.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">file</span>,</span><span class=\"param\">\t<span class=\"n\">variable</span>,</span><span class=\"param\">\t<span class=\"n\">start_year</span>,</span><span class=\"param\">\t<span class=\"n\">end_year</span>,</span><span class=\"param\">\t<span class=\"n\">multiplier</span>,</span><span class=\"param\">\t<span class=\"n\">return_column</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "e3sm_plot_time_series.read_file_set_into_single_variable_dataframe", "modulename": "e3sm_plot_time_series", "qualname": "read_file_set_into_single_variable_dataframe", "kind": "function", "doc": "<p>Reads a list of output files and the time series data for one specific variable in those files into a Pandas DataFrame. </p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>output_files:</strong>  List of lists (2D matrix) for the files. We want to read in one column of this matrix, which corresponds to a particular group\nof files that we want to collect together into a set and later plot the various set means of a larger ensemble of sets.</li>\n<li><strong>file_set_index:</strong>  The column number for the output_files matrix. This indicates the index for the group/set of files that are of interest.</li>\n<li><strong>variable:</strong>  The variable of interest.</li>\n<li><strong>start_year:</strong>  First year in the extracted time series data.</li>\n<li><strong>end_year:</strong>  Last year in the extracted time series data.</li>\n<li><strong>multiplier:</strong>  Multiplier on the time series (in case the user wants to change the units).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame containing data from all files for the variable and also all DataFrame columns for the variable, one column from each of the files.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">output_files</span>,</span><span class=\"param\">\t<span class=\"n\">file_set_index</span>,</span><span class=\"param\">\t<span class=\"n\">variable</span>,</span><span class=\"param\">\t<span class=\"n\">start_year</span>,</span><span class=\"param\">\t<span class=\"n\">end_year</span>,</span><span class=\"param\">\t<span class=\"n\">multiplier</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "e3sm_plot_time_series.plot_time_series", "modulename": "e3sm_plot_time_series", "qualname": "plot_time_series", "kind": "function", "doc": "<p>Create time series plots and performs statistical analysis for a single variable. \nTime series plots can be annual, with time presented in years (including seasonal variants that can be plotted separately), or \nmonthly, in which the values that are plotted indicate averages between specified start and end years for each month. \nTypes of plots: 1) Direct plots in which each output file is treated as an individual curve in the time series collection. 2) Ensemble plots in \nwhich the files are grouped into sets and averages of each set are plotted. Output files must be specified as a list of lists for ensemble plots.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>input:</strong>  Dictionary containing user inputs for different plotting options, where the keys are options and values are choices for those options.\nThis dictionary is assumed to be complete (pre-processed).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "e3sm_produce_synthetic_spatial_data", "modulename": "e3sm_produce_synthetic_spatial_data", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "e3sm_produce_synthetic_spatial_data.produce_synthetic_spatial_data", "modulename": "e3sm_produce_synthetic_spatial_data", "qualname": "produce_synthetic_spatial_data", "kind": "function", "doc": "<p>Produces a synthetic ensemble set of spatial data using random numbers to introduce perturbations to the time series in a given file. \nEach new synthetic spatial data map in the ensemble is output as a NetCDF file.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>inputs:</strong>  List with two items. The first item is the name of the file containing the base spatial data. \nThe second item is the total number of spatial data maps (including the base spatial data map) we want to include in the set.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "e3sm_produce_synthetic_time_series", "modulename": "e3sm_produce_synthetic_time_series", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "e3sm_produce_synthetic_time_series.produce_synthetic_time_series", "modulename": "e3sm_produce_synthetic_time_series", "qualname": "produce_synthetic_time_series", "kind": "function", "doc": "<p>Produces a synthetic ensemble set of time series using random numbers to introduce perturbations to the time series in a given file. \nEach new synthetic time series in the ensemble is output as a .dat or .csv file.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>inputs:</strong>  List with two items. The first item is the name of the file containing the base time series. \nThe second item is the total number of time series (including the base time series) we want to include in the set.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gcam_add_areas_to_files", "modulename": "gcam_add_areas_to_files", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "gcam_add_areas_to_files.add_areas_to_subset_of_file", "modulename": "gcam_add_areas_to_files", "qualname": "add_areas_to_subset_of_file", "kind": "function", "doc": "<p>Adds areas from land allocation data contained in a Pandas DataFrame to another DataFrame containing data for the quantity of interest.\nThis function adds areas to a subset of the DataFrame that matches the given scenario, geographical unit, and category.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df:</strong>  DataFrame containing the data of interest.</li>\n<li><strong>df_land:</strong>  DataFrame for the land allocation areas.</li>\n<li><strong>geographical_label:</strong>  String specifying the label for the geographical unit (e.g., 'region' or 'basin').</li>\n<li><strong>category_label:</strong>  String specifying the label for the appropriate category (e.g., 'sector' or 'landtype').</li>\n<li><strong>scenario:</strong>  String for the scenario (simulation name) of interest.</li>\n<li><strong>geography:</strong>  String specifying the name of the geographical unit for the subset of interest (e.g., the name of the region or the basin).</li>\n<li><strong>category:</strong>  String specifying the name of the category for the subset of interest (e.g., the name of the sector or the landtype).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame that is the same as the input df, but with an extra column for the corresponding land allocation areas.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">df_land</span>,</span><span class=\"param\">\t<span class=\"n\">geographical_label</span>,</span><span class=\"param\">\t<span class=\"n\">category_label</span>,</span><span class=\"param\">\t<span class=\"n\">scenario</span>,</span><span class=\"param\">\t<span class=\"n\">geography</span>,</span><span class=\"param\">\t<span class=\"n\">category</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gcam_add_areas_to_files.add_areas_to_file", "modulename": "gcam_add_areas_to_files", "qualname": "add_areas_to_file", "kind": "function", "doc": "<p>Adds areas from the land allocation file as an extra column to the file specified in the inputs dictionary.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>inputs:</strong>  Dictionary with user-specified inputs for the name of the input and output files, the name of the land allocation file, etc.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gcam_plot_box_and_whiskers", "modulename": "gcam_plot_box_and_whiskers", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "gcam_plot_box_and_whiskers.default_inputs_time_series", "modulename": "gcam_plot_box_and_whiskers", "qualname": "default_inputs_time_series", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;basin_label&#x27;: &#x27;basin&#x27;, &#x27;basins&#x27;: None, &#x27;category_label&#x27;: &#x27;sector&#x27;, &#x27;end_year&#x27;: 2100, &#x27;fill_boxes&#x27;: True, &#x27;height&#x27;: 8, &#x27;hue&#x27;: None, &#x27;key_columns&#x27;: None, &#x27;landtype_groups&#x27;: &#x27;standard&#x27;, &#x27;legend_x_offset&#x27;: None, &#x27;legend_label_size&#x27;: 14, &#x27;legend_num_columns&#x27;: 1, &#x27;legend_on&#x27;: True, &#x27;legend_place_outside&#x27;: False, &#x27;linewidth&#x27;: 1, &#x27;marker_size&#x27;: 6, &#x27;multiplier&#x27;: 1, &#x27;mean_or_sum_if_more_than_one_row_in_same_landtype_group&#x27;: &#x27;area_weighted_mean&#x27;, &#x27;plot_colors&#x27;: [&#x27;#1f77b4&#x27;, &#x27;#ff7f0e&#x27;, &#x27;#2ca02c&#x27;, &#x27;#d62728&#x27;, &#x27;#9467bd&#x27;, &#x27;#8c564b&#x27;, &#x27;#e377c2&#x27;, &#x27;#7f7f7f&#x27;, &#x27;#bcbd22&#x27;, &#x27;#17becf&#x27;, &#x27;#029386&#x27;, &#x27;#c20078&#x27;, &#x27;#53fca1&#x27;, &#x27;#fe01b1&#x27;, &#x27;#c65102&#x27;, &#x27;#fac205&#x27;, &#x27;#0b5509&#x27;, &#x27;#8a6e45&#x27;, &#x27;#fc5a50&#x27;, &#x27;#a2cffe&#x27;, &#x27;#ffb07c&#x27;], &#x27;plot_directory&#x27;: &#x27;./&#x27;, &#x27;plot_percent_difference&#x27;: False, &#x27;plot_type&#x27;: &#x27;ensemble_averages&#x27;, &#x27;produce_png&#x27;: False, &#x27;region_label&#x27;: &#x27;region&#x27;, &#x27;regions&#x27;: [&#x27;Global&#x27;], &#x27;scenario_label&#x27;: &#x27;scenario&#x27;, &#x27;scenario_sets&#x27;: None, &#x27;start_year&#x27;: 2015, &#x27;use_latex&#x27;: False, &#x27;value_label&#x27;: &#x27;value&#x27;, &#x27;width&#x27;: 10, &#x27;x_label&#x27;: None, &#x27;x_label_size&#x27;: 24, &#x27;x_scale&#x27;: None, &#x27;x_tick_label_size&#x27;: 20, &#x27;y_label_size&#x27;: 24, &#x27;y_limits&#x27;: None, &#x27;y_scale&#x27;: &#x27;linear&#x27;, &#x27;y_tick_label_size&#x27;: 20, &#x27;year_label&#x27;: &#x27;year&#x27;}"}, {"fullname": "gcam_plot_box_and_whiskers.process_inputs", "modulename": "gcam_plot_box_and_whiskers", "qualname": "process_inputs", "kind": "function", "doc": "<p>Processes a dictionary of inputs (keys are options, values are choices for those options) for creating box plots.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>inputs:</strong>  Dictionary containing the user plotting choice inputs for different options. This dictionary may be incomplete or have invalid values.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Dictionary that completely specifies all plotting options. \n  If the user did not select a plotting option fora particular category, the default choice for that plotting option will be selected.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gcam_plot_box_and_whiskers.plot_box_and_whiskers", "modulename": "gcam_plot_box_and_whiskers", "qualname": "plot_box_and_whiskers", "kind": "function", "doc": "<p>Creates a box plot (box-and-whisker plot) and perform statistical analysis for a single output file. The data in the file are organized\ninto scenarios or scenario sets, categories, and regions.\nTypes of plots: 1) Direct plots in which each scenario is treated as an individual data set in the collection. \n2) Ensemble plots in which the scenarios are grouped into sets and results from of each set are plotted. The scenarios must be specified as a \nlist of lists for ensemble plots.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>input:</strong>  Dictionary containing user inputs for different plotting options, where the keys are options and values are choices for those options.\nThis dictionary is assumed to be complete (pre-processed).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gcam_plot_time_series", "modulename": "gcam_plot_time_series", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "gcam_plot_time_series.default_inputs_time_series", "modulename": "gcam_plot_time_series", "qualname": "default_inputs_time_series", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;aggregation_type_in_each_year&#x27;: &#x27;mean&#x27;, &#x27;category_label&#x27;: &#x27;sector&#x27;, &#x27;end_year&#x27;: 2100, &#x27;error_bars_alpha&#x27;: 0.2, &#x27;height&#x27;: 8, &#x27;include_mean_across_all_data&#x27;: False, &#x27;key_columns&#x27;: None, &#x27;landtype_groups&#x27;: &#x27;standard&#x27;, &#x27;legend_x_offset&#x27;: None, &#x27;legend_label_size&#x27;: 14, &#x27;legend_num_columns&#x27;: None, &#x27;legend_on&#x27;: True, &#x27;legend_place_outside&#x27;: True, &#x27;linestyle_tuples&#x27;: [(&#x27;solid&#x27;, (0, ())), (&#x27;dashed&#x27;, (0, (5, 5))), (&#x27;dotted&#x27;, (0, (1, 5))), (&#x27;dashdot&#x27;, (0, (3, 5, 1, 5))), (&#x27;loosely dotted&#x27;, (0, (1, 10))), (&#x27;loosely dashed&#x27;, (0, (5, 10))), (&#x27;densely dashed&#x27;, (0, (5, 1))), (&#x27;loosely dashdotted&#x27;, (0, (3, 10, 1, 10))), (&#x27;densely dashdotted&#x27;, (0, (3, 1, 1, 1))), (&#x27;dashdotdotted&#x27;, (0, (3, 5, 1, 5, 1, 5))), (&#x27;loosely dashdotdotted&#x27;, (0, (3, 10, 1, 10, 1, 10))), (&#x27;densely dashdotdotted&#x27;, (0, (3, 1, 1, 1, 1, 1)))], &#x27;linewidth&#x27;: 2, &#x27;marker_size&#x27;: 6, &#x27;markers&#x27;: [&#x27;o&#x27;, &#x27;v&#x27;, &#x27;^&#x27;, &#x27;&lt;&#x27;, &#x27;&gt;&#x27;, &#x27;8&#x27;, &#x27;s&#x27;, &#x27;p&#x27;, &#x27;*&#x27;, &#x27;h&#x27;, &#x27;H&#x27;, &#x27;D&#x27;, &#x27;d&#x27;, &#x27;P&#x27;, &#x27;X&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;+&#x27;, &#x27;x&#x27;, &#x27;|&#x27;], &#x27;multiplier&#x27;: 1, &#x27;mean_or_sum_if_more_than_one_row_in_same_landtype_group&#x27;: &#x27;area_weighted_mean&#x27;, &#x27;p_value_file&#x27;: &#x27;p_values.dat&#x27;, &#x27;p_value_file_print_only_if_below_threshold&#x27;: True, &#x27;p_value_marker_size&#x27;: 10, &#x27;p_value_threshold&#x27;: 0.05, &#x27;plot_colors&#x27;: [&#x27;#1f77b4&#x27;, &#x27;#ff7f0e&#x27;, &#x27;#2ca02c&#x27;, &#x27;#d62728&#x27;, &#x27;#9467bd&#x27;, &#x27;#8c564b&#x27;, &#x27;#e377c2&#x27;, &#x27;#7f7f7f&#x27;, &#x27;#bcbd22&#x27;, &#x27;#17becf&#x27;, &#x27;#029386&#x27;, &#x27;#c20078&#x27;, &#x27;#53fca1&#x27;, &#x27;#fe01b1&#x27;, &#x27;#c65102&#x27;, &#x27;#fac205&#x27;, &#x27;#0b5509&#x27;, &#x27;#8a6e45&#x27;, &#x27;#fc5a50&#x27;, &#x27;#a2cffe&#x27;, &#x27;#ffb07c&#x27;], &#x27;plot_directory&#x27;: &#x27;./&#x27;, &#x27;plot_percent_difference&#x27;: False, &#x27;plot_type&#x27;: &#x27;ensemble_averages&#x27;, &#x27;produce_png&#x27;: False, &#x27;region_label&#x27;: &#x27;region&#x27;, &#x27;regions&#x27;: [&#x27;Global&#x27;], &#x27;scenario_label&#x27;: &#x27;scenario&#x27;, &#x27;scenario_sets&#x27;: None, &#x27;start_year&#x27;: 2015, &#x27;std_mean_across_all_data_multiplier&#x27;: 1, &#x27;std_multiplier&#x27;: 1, &#x27;use_latex&#x27;: False, &#x27;value_label&#x27;: &#x27;value&#x27;, &#x27;width&#x27;: 10, &#x27;x_label_size&#x27;: 24, &#x27;x_limits&#x27;: None, &#x27;x_scale&#x27;: &#x27;linear&#x27;, &#x27;x_tick_label_size&#x27;: 20, &#x27;y_label_size&#x27;: 24, &#x27;y_limits&#x27;: None, &#x27;y_scale&#x27;: &#x27;linear&#x27;, &#x27;y_tick_label_size&#x27;: 20, &#x27;year_label&#x27;: &#x27;year&#x27;}"}, {"fullname": "gcam_plot_time_series.process_inputs", "modulename": "gcam_plot_time_series", "qualname": "process_inputs", "kind": "function", "doc": "<p>Processes a dictionary of inputs (keys are options, values are choices for those options) for creating time series plots.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>inputs:</strong>  Dictionary containing the user plotting choice inputs for different options. This dictionary may be incomplete or have invalid values.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Dictionary that completely specifies all plotting options. \n  If the user did not select a plotting option fora particular category, the default choice for that plotting option will be selected.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gcam_plot_time_series.plot_time_series", "modulename": "gcam_plot_time_series", "qualname": "plot_time_series", "kind": "function", "doc": "<p>Creates a time series plot with years on the x-axis and perform statistical analysis for a single output file. The data in the file are organized\ninto scenarios or scenario sets, categories, and regions.\nTypes of plots: 1) Direct plots in which each scenario is treated as an individual curve in the time series collection. \n2) Ensemble plots in which the scenarios are grouped into sets and averages of each set are plotted. The scenarios must be specified as a \nlist of lists for ensemble plots.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>input:</strong>  Dictionary containing user inputs for different plotting options, where the keys are options and values are choices for those options.\nThis dictionary is assumed to be complete (pre-processed).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gcam_process_and_compile_ehc_scalars", "modulename": "gcam_process_and_compile_ehc_scalars", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "gcam_process_and_compile_ehc_scalars.process_and_compile_ehc_scalars", "modulename": "gcam_process_and_compile_ehc_scalars", "qualname": "process_and_compile_ehc_scalars", "kind": "function", "doc": "<p>Processes and compiles the scalars files generated at run time by the E3SM human component (EHC) and subsequently gets passed into GCAM. \nThe files are located in multiple directories into a single output file that gets written to a .dat or .csv file.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>inputs:</strong>  Dictionary with user-specified inputs for the directory paths, the name of the output file, whether we want to standardize the\ncrop names, and a list of scenario names, with each scenario in the list corresponding to one directory.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gcam_process_extracted_data", "modulename": "gcam_process_extracted_data", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "gcam_process_extracted_data.process_extracted_data", "modulename": "gcam_process_extracted_data", "qualname": "process_extracted_data", "kind": "function", "doc": "<p>Processes a file containing data extracted from GCAM project files using XML queries. The data are rearranged, split, aggregated in various ways,\nincluding potentially aggregating landtype groups, and the resulting processed data then gets written as an output file in .dat or .csv format.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>inputs:</strong>  Dictionary with user-specified inputs, like the names of the input file (the one extracted from GCAM) and the output (processed) file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gcam_produce_synthetic_data", "modulename": "gcam_produce_synthetic_data", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "gcam_produce_synthetic_data.produce_synthetic_time_series", "modulename": "gcam_produce_synthetic_data", "qualname": "produce_synthetic_time_series", "kind": "function", "doc": "<p>Produces a synthetic ensemble set of time series using random numbers to introduce perturbations to the time series in a given file. \nEach new synthetic time series in the ensemble is output as a .dat or .csv file.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>inputs:</strong>  List with five items. The first item is the name of the file containing the base time series. \nThe second item is a list of the scenarios in the file.\nThe third item contains the label for the scenario column in the file.\nThe fourth item is a list of the column labels representing the numerical data for each scenario.\nThe fifth item is the total number of time series (including the base time series) we want to include in the set.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gcam_test", "modulename": "gcam_test", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "gcam_test.default_inputs_time_series", "modulename": "gcam_test", "qualname": "default_inputs_time_series", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;aggregation_type_in_each_year&#x27;: &#x27;mean&#x27;, &#x27;category_label&#x27;: &#x27;sector&#x27;, &#x27;end_year&#x27;: 2100, &#x27;error_bars_alpha&#x27;: 0.2, &#x27;height&#x27;: 8, &#x27;include_mean_across_all_data&#x27;: False, &#x27;key_columns&#x27;: None, &#x27;landtype_groups&#x27;: &#x27;standard&#x27;, &#x27;legend_x_offset&#x27;: None, &#x27;legend_label_size&#x27;: 14, &#x27;legend_num_columns&#x27;: None, &#x27;legend_on&#x27;: True, &#x27;legend_place_outside&#x27;: True, &#x27;linestyle_tuples&#x27;: [(&#x27;solid&#x27;, (0, ())), (&#x27;dashed&#x27;, (0, (5, 5))), (&#x27;dotted&#x27;, (0, (1, 5))), (&#x27;dashdot&#x27;, (0, (3, 5, 1, 5))), (&#x27;loosely dotted&#x27;, (0, (1, 10))), (&#x27;loosely dashed&#x27;, (0, (5, 10))), (&#x27;densely dashed&#x27;, (0, (5, 1))), (&#x27;loosely dashdotted&#x27;, (0, (3, 10, 1, 10))), (&#x27;densely dashdotted&#x27;, (0, (3, 1, 1, 1))), (&#x27;dashdotdotted&#x27;, (0, (3, 5, 1, 5, 1, 5))), (&#x27;loosely dashdotdotted&#x27;, (0, (3, 10, 1, 10, 1, 10))), (&#x27;densely dashdotdotted&#x27;, (0, (3, 1, 1, 1, 1, 1)))], &#x27;linewidth&#x27;: 2, &#x27;marker_size&#x27;: 6, &#x27;markers&#x27;: [&#x27;o&#x27;, &#x27;v&#x27;, &#x27;^&#x27;, &#x27;&lt;&#x27;, &#x27;&gt;&#x27;, &#x27;8&#x27;, &#x27;s&#x27;, &#x27;p&#x27;, &#x27;*&#x27;, &#x27;h&#x27;, &#x27;H&#x27;, &#x27;D&#x27;, &#x27;d&#x27;, &#x27;P&#x27;, &#x27;X&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;+&#x27;, &#x27;x&#x27;, &#x27;|&#x27;], &#x27;multiplier&#x27;: 1, &#x27;mean_or_sum_if_more_than_one_row_in_same_landtype_group&#x27;: &#x27;area_weighted_mean&#x27;, &#x27;p_value_file&#x27;: &#x27;p_values.dat&#x27;, &#x27;p_value_file_print_only_if_below_threshold&#x27;: True, &#x27;p_value_marker_size&#x27;: 10, &#x27;p_value_threshold&#x27;: 0.05, &#x27;plot_colors&#x27;: [&#x27;#1f77b4&#x27;, &#x27;#ff7f0e&#x27;, &#x27;#2ca02c&#x27;, &#x27;#d62728&#x27;, &#x27;#9467bd&#x27;, &#x27;#8c564b&#x27;, &#x27;#e377c2&#x27;, &#x27;#7f7f7f&#x27;, &#x27;#bcbd22&#x27;, &#x27;#17becf&#x27;, &#x27;#029386&#x27;, &#x27;#c20078&#x27;, &#x27;#53fca1&#x27;, &#x27;#fe01b1&#x27;, &#x27;#c65102&#x27;, &#x27;#fac205&#x27;, &#x27;#0b5509&#x27;, &#x27;#8a6e45&#x27;, &#x27;#fc5a50&#x27;, &#x27;#a2cffe&#x27;, &#x27;#ffb07c&#x27;], &#x27;plot_directory&#x27;: &#x27;./&#x27;, &#x27;plot_percent_difference&#x27;: False, &#x27;plot_type&#x27;: &#x27;ensemble_averages&#x27;, &#x27;produce_png&#x27;: False, &#x27;region_label&#x27;: &#x27;region&#x27;, &#x27;regions&#x27;: [&#x27;Global&#x27;], &#x27;scenario_label&#x27;: &#x27;scenario&#x27;, &#x27;scenario_sets&#x27;: None, &#x27;start_year&#x27;: 2015, &#x27;std_mean_across_all_data_multiplier&#x27;: 1, &#x27;std_multiplier&#x27;: 1, &#x27;use_latex&#x27;: False, &#x27;value_label&#x27;: &#x27;value&#x27;, &#x27;width&#x27;: 10, &#x27;x_label_size&#x27;: 24, &#x27;x_limits&#x27;: None, &#x27;x_scale&#x27;: &#x27;linear&#x27;, &#x27;x_tick_label_size&#x27;: 20, &#x27;y_label_size&#x27;: 24, &#x27;y_limits&#x27;: None, &#x27;y_scale&#x27;: &#x27;linear&#x27;, &#x27;y_tick_label_size&#x27;: 20, &#x27;year_label&#x27;: &#x27;year&#x27;}"}, {"fullname": "gcam_test.process_inputs", "modulename": "gcam_test", "qualname": "process_inputs", "kind": "function", "doc": "<p>Processes a dictionary of inputs (keys are options, values are choices for those options) for creating time series plots.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>inputs:</strong>  Dictionary containing the user plotting choice inputs for different options. This dictionary may be incomplete or have invalid values.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Dictionary that completely specifies all plotting options. \n  If the user did not select a plotting option fora particular category, the default choice for that plotting option will be selected.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gcam_test.plot_time_series", "modulename": "gcam_test", "qualname": "plot_time_series", "kind": "function", "doc": "<p>Creates a time series plot with years on the x-axis and perform statistical analysis for a single output file. The data in the file are organized\ninto scenarios or scenario sets, categories, and regions.\nTypes of plots: 1) Direct plots in which each scenario is treated as an individual curve in the time series collection. \n2) Ensemble plots in which the scenarios are grouped into sets and averages of each set are plotted. The scenarios must be specified as a \nlist of lists for ensemble plots.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>input:</strong>  Dictionary containing user inputs for different plotting options, where the keys are options and values are choices for those options.\nThis dictionary is assumed to be complete (pre-processed).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_constants", "modulename": "utility_constants", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "utility_constants.km_TO_m", "modulename": "utility_constants", "qualname": "km_TO_m", "kind": "variable", "doc": "<p></p>\n", "default_value": "1000.0"}, {"fullname": "utility_constants.km2_TO_m2", "modulename": "utility_constants", "qualname": "km2_TO_m2", "kind": "variable", "doc": "<p></p>\n", "default_value": "1000000.0"}, {"fullname": "utility_constants.days_TO_s", "modulename": "utility_constants", "qualname": "days_TO_s", "kind": "variable", "doc": "<p></p>\n", "default_value": "86400"}, {"fullname": "utility_constants.days_TO_hours", "modulename": "utility_constants", "qualname": "days_TO_hours", "kind": "variable", "doc": "<p></p>\n", "default_value": "24"}, {"fullname": "utility_constants.hours_TO_mins", "modulename": "utility_constants", "qualname": "hours_TO_mins", "kind": "variable", "doc": "<p></p>\n", "default_value": "60"}, {"fullname": "utility_constants.years_TO_days", "modulename": "utility_constants", "qualname": "years_TO_days", "kind": "variable", "doc": "<p></p>\n", "default_value": "365"}, {"fullname": "utility_constants.years_TO_s", "modulename": "utility_constants", "qualname": "years_TO_s", "kind": "variable", "doc": "<p></p>\n", "default_value": "31536000"}, {"fullname": "utility_constants.years_TO_months", "modulename": "utility_constants", "qualname": "years_TO_months", "kind": "variable", "doc": "<p></p>\n", "default_value": "12"}, {"fullname": "utility_constants.years_TO_hours", "modulename": "utility_constants", "qualname": "years_TO_hours", "kind": "variable", "doc": "<p></p>\n", "default_value": "8760"}, {"fullname": "utility_constants.years_TO_mins", "modulename": "utility_constants", "qualname": "years_TO_mins", "kind": "variable", "doc": "<p></p>\n", "default_value": "525600"}, {"fullname": "utility_constants.kg_TO_g", "modulename": "utility_constants", "qualname": "kg_TO_g", "kind": "variable", "doc": "<p></p>\n", "default_value": "1000.0"}, {"fullname": "utility_constants.Pg_TO_kg", "modulename": "utility_constants", "qualname": "Pg_TO_kg", "kind": "variable", "doc": "<p></p>\n", "default_value": "1000000000000.0"}, {"fullname": "utility_constants.Pg_TO_g", "modulename": "utility_constants", "qualname": "Pg_TO_g", "kind": "variable", "doc": "<p></p>\n", "default_value": "1000000000000000.0"}, {"fullname": "utility_constants.m_TO_mm", "modulename": "utility_constants", "qualname": "m_TO_mm", "kind": "variable", "doc": "<p></p>\n", "default_value": "1000.0"}, {"fullname": "utility_constants.mole_fraction_TO_ppm", "modulename": "utility_constants", "qualname": "mole_fraction_TO_ppm", "kind": "variable", "doc": "<p>Tiny constant used to avoid divide-by-zero errors.</p>\n", "default_value": "1000000.0"}, {"fullname": "utility_constants.EPSILON", "modulename": "utility_constants", "qualname": "EPSILON", "kind": "variable", "doc": "<p>Number of days and seconds in each month (no leap years).</p>\n", "default_value": "1e-14"}, {"fullname": "utility_constants.NUM_DAYS_IN_MONTHS", "modulename": "utility_constants", "qualname": "NUM_DAYS_IN_MONTHS", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31])"}, {"fullname": "utility_constants.NUM_SECONDS_IN_MONTHS", "modulename": "utility_constants", "qualname": "NUM_SECONDS_IN_MONTHS", "kind": "variable", "doc": "<p>Molar mass of carbon (g/mol).</p>\n", "default_value": "array([2678400, 2419200, 2678400, 2592000, 2678400, 2592000, 2678400,\n       2678400, 2592000, 2678400, 2592000, 2678400])"}, {"fullname": "utility_constants.MM_C", "modulename": "utility_constants", "qualname": "MM_C", "kind": "variable", "doc": "<p>Molar mass of CO2 (g/mol).</p>\n", "default_value": "12.011"}, {"fullname": "utility_constants.MM_CO2", "modulename": "utility_constants", "qualname": "MM_CO2", "kind": "variable", "doc": "<p>Molar mass of CH4 (g/mol).</p>\n", "default_value": "44.009"}, {"fullname": "utility_constants.MM_CH4", "modulename": "utility_constants", "qualname": "MM_CH4", "kind": "variable", "doc": "<p>Molar mass of atmosphere avg (g/mol) (dry).</p>\n", "default_value": "16.043"}, {"fullname": "utility_constants.MM_ATM", "modulename": "utility_constants", "qualname": "MM_ATM", "kind": "variable", "doc": "<p>Surface area of Earth in m^2. Based on authalic radius, which is a spherical radius that gives same surface area \nas the reference ellipsoid, which is wgs84.</p>\n", "default_value": "28.965"}, {"fullname": "utility_constants.SURF_AREA", "modulename": "utility_constants", "qualname": "SURF_AREA", "kind": "variable", "doc": "<p>Dictionary between month number and name.</p>\n", "default_value": "510065592755264.56"}, {"fullname": "utility_constants.MONTH_NUM_TO_NAME", "modulename": "utility_constants", "qualname": "MONTH_NUM_TO_NAME", "kind": "variable", "doc": "<p></p>\n", "default_value": "{1: &#x27;January&#x27;, 2: &#x27;February&#x27;, 3: &#x27;March&#x27;, 4: &#x27;April&#x27;, 5: &#x27;May&#x27;, 6: &#x27;June&#x27;, 7: &#x27;July&#x27;, 8: &#x27;August&#x27;, 9: &#x27;September&#x27;, 10: &#x27;October&#x27;, 11: &#x27;November&#x27;, 12: &#x27;December&#x27;}"}, {"fullname": "utility_dataframes", "modulename": "utility_dataframes", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "utility_dataframes.clean_up_dataframe", "modulename": "utility_dataframes", "qualname": "clean_up_dataframe", "kind": "function", "doc": "<p>Cleans up a Pandas DataFrame from junk columns that contain only NaN values and returns this cleaned-up DataFrame.\nThe junk columns may be a result of pd.read_fwf() separating out a single column with a long label into two columns where the second column \ncontains the junk values. For example, the column \"rho A+B+C (g/cm^3)\" may get separated to \"rho A+B+C\" and \"(g/cm^3)\", in which the latter\ncolumn, which will contain only NaN entries, should be deleted.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df:</strong>  DataFrame to be cleaned.</li>\n<li><strong>print_to_console:</strong>  Indicates if the contents of the data should be printed to the console to monitor the progress.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>df: DataFrame after cleaning operations have been applied.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">print_to_console</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_dataframes.get_columns_without_units_in_dataframe", "modulename": "utility_dataframes", "qualname": "get_columns_without_units_in_dataframe", "kind": "function", "doc": "<p>Returns all column names in a Pandas DataFrame without the units. For example, return 'Mass' if the colum name is 'Mass (kg)'.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df:</strong>  The input DataFrame.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A list of all column names, with the units removed.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_dataframes.get_matching_column_in_dataframe", "modulename": "utility_dataframes", "qualname": "get_matching_column_in_dataframe", "kind": "function", "doc": "<p>Returns the column name(s) in a Pandas DataFrame that matches the variable.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df:</strong>  The input DataFrame.</li>\n<li><strong>variable:</strong>  Variable name to search for in the column names.</li>\n<li><strong>all_matches:</strong>  If True, all columns that matches the variable will be returned. If False, only the first matching column will be returned.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The matching column name(s), or None if no match is found.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">variable</span>, </span><span class=\"param\"><span class=\"n\">all_matches</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_dataframes.move_columns_next_to_each_other_in_dataframe", "modulename": "utility_dataframes", "qualname": "move_columns_next_to_each_other_in_dataframe", "kind": "function", "doc": "<p>Rearranges a Pandas DataFrame by moving column2 next to column1.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>column1:</strong>  Column next to which column2 will be moved. The order of all columns prior to column1 will be unaffected.</li>\n<li><strong>column2:</strong>  Column to move next to column1.</li>\n<li><strong>df:</strong>  DataFrame whose columns will be rearranged.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new DataFrame with column1 and column2 moved next to each other.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">column1</span>, </span><span class=\"param\"><span class=\"n\">column2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_dataframes.perform_ttest", "modulename": "utility_dataframes", "qualname": "perform_ttest", "kind": "function", "doc": "<p>Performs a t-test for the means of two (presumed) independent data sets.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df:</strong>  Pandas DataFrame containing the columns for both data sets.</li>\n<li><strong>columns_set_1:</strong>  List of columns in the DataFrame for the first data set.</li>\n<li><strong>columns_set_2:</strong>  List of columns in the DataFrame for the second data set.</li>\n<li><strong>equal_var:</strong>  Boolean that indicates if the two samples are characterized by the same variance.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The p-value produced by the t-test.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">columns_set_1</span>, </span><span class=\"param\"><span class=\"n\">columns_set_2</span>, </span><span class=\"param\"><span class=\"n\">equal_var</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_dataframes.read_file_into_dataframe", "modulename": "utility_dataframes", "qualname": "read_file_into_dataframe", "kind": "function", "doc": "<p>Reads a csv or fixed-width-format file, puts the contents into a Pandas DataFrame, and returns the DataFrame.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>file_name:</strong>  Complete path and name of the output file.</li>\n<li><strong>clean_up_df:</strong>  Boolean that specifies if we want to call clean_up_dataframe() on the DataFrame before returning it.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame containing the contents of the file.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_name</span>, </span><span class=\"param\"><span class=\"n\">clean_up_df</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_dataframes.write_data_and_labels_to_csv", "modulename": "utility_dataframes", "qualname": "write_data_and_labels_to_csv", "kind": "function", "doc": "<p>Stores the given data and column labels in a Pandas DataFrame and writes the contents of the DataFrame to a csv file.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>file_name:</strong>  Complete path and name of the output file.</li>\n<li><strong>data:</strong>  Contains one or more columns of data.</li>\n<li><strong>column_labels:</strong>  List of strings representing the column labels.</li>\n<li><strong>transpose_data:</strong>  Indicates if it is necessary to transpose the data (which it would be if the data are stored in a list of lists, for example)\nso that the data appear along the columns of the output file rather along the rows.</li>\n<li><strong>keep_index_column:</strong>  Specifies whether to print the index column in the output file.</li>\n<li><strong>keep_header:</strong>  Indicates if the output file should contain headers for column labels.</li>\n<li><strong>separation:</strong>  Indicates the character(s) to be used as column separators.</li>\n<li><strong>format:</strong>  Format for floats in the output file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">file_name</span>,</span><span class=\"param\">\t<span class=\"n\">data</span>,</span><span class=\"param\">\t<span class=\"n\">column_labels</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">transpose_data</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">keep_index_column</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">keep_header</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">separation</span><span class=\"o\">=</span><span class=\"s1\">&#39;,&#39;</span>,</span><span class=\"param\">\t<span class=\"nb\">format</span><span class=\"o\">=</span><span class=\"s1\">&#39;</span><span class=\"si\">%12.8e</span><span class=\"s1\">&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_dataframes.write_data_and_labels_to_fwf", "modulename": "utility_dataframes", "qualname": "write_data_and_labels_to_fwf", "kind": "function", "doc": "<p>Stores the given data and column labels in a Pandas DataFrame and writes the contents of the DataFrame to an output file in fixed-width format.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>file_name:</strong>  Complete path and name of the output file.</li>\n<li><strong>data:</strong>  Contains one or more columns of data.</li>\n<li><strong>column_labels:</strong>  List of strings representing the column labels.</li>\n<li><strong>transpose_data:</strong>  Indicates if it is necessary to transpose the data (which it would be if the data are stored in a list of lists, for example)\nso that the data appear along the columns of the output file rather along the rows.</li>\n<li><strong>keep_index_column:</strong>  Specifies whether to print the index column in the output file.</li>\n<li><strong>print_to_console:</strong>  Indicates if the contents of the data should be printed to the console.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">file_name</span>,</span><span class=\"param\">\t<span class=\"n\">data</span>,</span><span class=\"param\">\t<span class=\"n\">column_labels</span>,</span><span class=\"param\">\t<span class=\"n\">transpose_data</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">keep_index_column</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">print_to_console</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_dataframes.write_dataframe_to_fwf", "modulename": "utility_dataframes", "qualname": "write_dataframe_to_fwf", "kind": "function", "doc": "<p>Writes the contents of a Pandas DataFrame to an output file in fixed-width format (fwf), omitting the index column if specified to do so.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>file_name:</strong>  Complete path and name of the output file.</li>\n<li><strong>df:</strong>  DataFrame in which the data to be written to the output file are stored.</li>\n<li><strong>keep_index_column:</strong>  Specifies whether to print the index column in the output file.</li>\n<li><strong>width_index_column:</strong>  Specifies the number of characters that span the width of the index column.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_name</span>, </span><span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">keep_index_column</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">width_index_column</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_e3sm_netcdf", "modulename": "utility_e3sm_netcdf", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "utility_e3sm_netcdf.extract_year_and_month_from_name_of_netcdf_file", "modulename": "utility_e3sm_netcdf", "qualname": "extract_year_and_month_from_name_of_netcdf_file", "kind": "function", "doc": "<p>Finds the year and month from the name of a given E3SM-generated NetCDF file.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>file:</strong>  NetCDF file containing data for one month in a particular year.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The year and month indicated in the name of the NetCDF file.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_e3sm_netcdf.find_gridcell_areas_in_netcdf_file", "modulename": "utility_e3sm_netcdf", "qualname": "find_gridcell_areas_in_netcdf_file", "kind": "function", "doc": "<p>Obtains the grid cell areas of all latitude/longitude coordinates in an E3SM-generated (EAM or ELM or EHC) NetCDF file for the given region.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>file:</strong>  NetCDF file.</li>\n<li><strong>region:</strong>  String for the region of interest. If not specified or not recognized, then there will be no restrictions on the lat/lon coordinates. </li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>NumPy array containing the grid cell areas of all coordinates in units of m^2 and an xarray Dataset containing data from the file.\n  Also returns the land and non-land (which is defined as ocean if in the case of EAM) fractions.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file</span>, </span><span class=\"param\"><span class=\"n\">region</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_e3sm_netcdf.get_netcdf_files_between_start_and_end_years", "modulename": "utility_e3sm_netcdf", "qualname": "get_netcdf_files_between_start_and_end_years", "kind": "function", "doc": "<p>Finds all E3SM-generated NetCDF files in a given list that fall between the start and end years.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>files:</strong>  List of NetCDF files.</li>\n<li><strong>start_year:</strong>  Start year.</li>\n<li><strong>end_year:</strong>  End year.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>List containing the NetCDF files that fall between the start and end years.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">files</span>, </span><span class=\"param\"><span class=\"n\">start_year</span>, </span><span class=\"param\"><span class=\"n\">end_year</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_e3sm_netcdf.get_regional_bounds", "modulename": "utility_e3sm_netcdf", "qualname": "get_regional_bounds", "kind": "function", "doc": "<p>Finds and returns a NumPy array that indicates the bounds on the longitude and latitude for given a geographical region.\nAdapted from a script by Daniel Ricciuto: /home/ac.eva.sinha/Sinha-etal-2025/workflow/e3sm_diags/diags_lineplots_hist_ZATM.py.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>region:</strong>  String for the geographical region.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>NumPy array with four numbers, [-min_lon, max_lon, min_lat, max_lat]. If the selected region is not recognized, returns [0, 360, -90, 90].</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">region</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_functions", "modulename": "utility_functions", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "utility_functions.add_lists_elementwise", "modulename": "utility_functions", "qualname": "add_lists_elementwise", "kind": "function", "doc": "<p>Performs elementwise addition of two lists.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>list1:</strong>  The first list.</li>\n<li><strong>list2:</strong>  The second list.</li>\n<li><strong>list2_are_units:</strong>  Boolean that specifies whether list2 represents the units corresponding to list1. This would be useful when forming \ncolumn headers, where list1 specifies the quantities and list2 specifies the corresponding units for those quantities.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new list containing the element-wise sums of list1 and list2. If list2_are_units is True, then the elements of list2 will be in parentheses \n  so that each element of the combined list will be of the form 'a (b)', where a is from list1 and b is from list2.\n  Returns None if the lists are not of the same length.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">list1</span>, </span><span class=\"param\"><span class=\"n\">list2</span>, </span><span class=\"param\"><span class=\"n\">list2_are_units</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_functions.check_is_list_of_lists", "modulename": "utility_functions", "qualname": "check_is_list_of_lists", "kind": "function", "doc": "<p>Checks if the given iterable is a list of lists.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data:</strong>  Iterable we want to check is a list of lists.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>True if data is a list of lists, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_functions.check_substrings_in_list", "modulename": "utility_functions", "qualname": "check_substrings_in_list", "kind": "function", "doc": "<p>Checks if either all or any of the elements of the substrings list are substrings of at least one element in list.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>substring:</strong>  A list of strings (substrings to search for).</li>\n<li><strong>list:</strong>  A list of strings (strings to search within).</li>\n<li><strong>all_or_any:</strong>  String whose value should be either 'all' or 'any'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>True if either all or any of the elements of substrings are substrings of at least one element in list, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">substrings</span>, </span><span class=\"param\"><span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">all_or_any</span><span class=\"o\">=</span><span class=\"s1\">&#39;all&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_functions.check_substrings_in_string", "modulename": "utility_functions", "qualname": "check_substrings_in_string", "kind": "function", "doc": "<p>Checks if either all or any of the elements of the substrings list are substrings of the string.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>substring:</strong>  A list of strings (substrings to search for).</li>\n<li><strong>string:</strong>  String to search within.</li>\n<li><strong>all_or_any:</strong>  String whose value should be either 'all' or 'any'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>True if either all or any of the elements of the substrings list are substrings of the string, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">substrings</span>, </span><span class=\"param\"><span class=\"n\">string</span>, </span><span class=\"param\"><span class=\"n\">all_or_any</span><span class=\"o\">=</span><span class=\"s1\">&#39;all&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_functions.convert_month_numbers_to_", "modulename": "utility_functions", "qualname": "convert_month_numbers_to_", "kind": "function", "doc": "<p>Checks if either all or any of the elements of the substrings list are substrings of the string.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>substring:</strong>  A list of strings (substrings to search for).</li>\n<li><strong>string:</strong>  String to search within.</li>\n<li><strong>all_or_any:</strong>  String whose value should be either 'all' or 'any'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>True if either all or any of the elements of substrings are substrings of the string, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">substrings</span>, </span><span class=\"param\"><span class=\"n\">string</span>, </span><span class=\"param\"><span class=\"n\">all_or_any</span><span class=\"o\">=</span><span class=\"s1\">&#39;all&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_functions.create_numpy_array_from_ds", "modulename": "utility_functions", "qualname": "create_numpy_array_from_ds", "kind": "function", "doc": "<p>Creates a list of NumPy arrays from the specified variables of an xarray Dataset. </p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>ds:</strong>  xarray Dataset.</li>\n<li><strong>variables:</strong>  List of variables.</li>\n<li><strong>fill_nan_values:</strong>  List that indicates what to set NaN values to for each variable.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>List of arrays, one for each ds variable. If only one variable is specified, then a single array (not a list with this array) is returned.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ds</span>, </span><span class=\"param\"><span class=\"n\">variables</span>, </span><span class=\"param\"><span class=\"n\">fill_nan_values</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_functions.find_between_chars", "modulename": "utility_functions", "qualname": "find_between_chars", "kind": "function", "doc": "<p>Finds and returns the substring located between the first occurrence of start_char and the first occurrence of end_char after start_char.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>text:</strong>  The string to search within.</li>\n<li><strong>start_char:</strong>  The character marking the beginning of the desired substring.</li>\n<li><strong>end_char:</strong>  The character marking the end of the desired substring.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str or None: The extracted substring if both characters are found in order, otherwise None.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">text</span>, </span><span class=\"param\"><span class=\"n\">start_char</span>, </span><span class=\"param\"><span class=\"n\">end_char</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_functions.get_all_files_in_path", "modulename": "utility_functions", "qualname": "get_all_files_in_path", "kind": "function", "doc": "<p>Gets a list of complete paths for all files that are in a particular directory.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>path:</strong>  Path of directory where we want to search for files.</li>\n<li><strong>file_name_substrings:</strong>  A list of all substrings that must be in the file names.</li>\n<li><strong>file_extension:</strong>  File extension that should be in all files. </li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A list with complete paths to all files in the directory. \n  If both file_name_substrings and file_extension are None, then all files in the directory will be included in the list.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span>, </span><span class=\"param\"><span class=\"n\">file_name_substrings</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">file_extension</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_functions.modify_list_based_on_condition", "modulename": "utility_functions", "qualname": "modify_list_based_on_condition", "kind": "function", "doc": "<p>Modifies a list by applying a condition and a function to generate new values.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>original_list:</strong>  The list to be modified.</li>\n<li><strong>condition:</strong>  A function that takes an element as input and returns True if the condition is met, and False otherwise.</li>\n<li><strong>new_value_function:</strong>  A function that takes an element as input and returns the new value to replace the original element.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new list with the modified elements.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">original_list</span>, </span><span class=\"param\"><span class=\"n\">condition</span>, </span><span class=\"param\"><span class=\"n\">new_value_function</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_functions.print_p_values", "modulename": "utility_functions", "qualname": "print_p_values", "kind": "function", "doc": "<p>Prints the p-values from a t-test to the console and optionally prints to an output file.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>ttest:</strong>  t-test object.</li>\n<li><strong>variable:</strong>  Variable for which the t-test was performed.</li>\n<li><strong>p_value_threshold:</strong>  Threshold for the p-value. The message to the console will indicate if the p-value falls below this threshold.</li>\n<li><strong>p_value_file:</strong>  Path and name for the file where the p-value result will be printed.</li>\n<li><strong>output_file_or_label:</strong>  Output file or label from where the data used to perform the t-test were obtained.</li>\n<li><strong>p_value_file_print_only_if_below_threshold:</strong>  If true, the p-value gets printed to the file only if it falls below the threshold.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ttest</span>,</span><span class=\"param\">\t<span class=\"n\">variable</span>,</span><span class=\"param\">\t<span class=\"n\">p_value_threshold</span>,</span><span class=\"param\">\t<span class=\"n\">p_value_file</span>,</span><span class=\"param\">\t<span class=\"n\">output_file_or_label</span>,</span><span class=\"param\">\t<span class=\"n\">p_value_file_print_only_if_below_threshold</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_functions.replace_inside_parentheses", "modulename": "utility_functions", "qualname": "replace_inside_parentheses", "kind": "function", "doc": "<p>Replaces the string inside parentheses with a given replacement string.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>text:</strong>  The input string.</li>\n<li><strong>replacement:</strong>  The string with which we will replace the content inside parentheses.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The modified string with the content inside parentheses replaced.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">text</span>, </span><span class=\"param\"><span class=\"n\">replacement</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_functions.sort_file", "modulename": "utility_functions", "qualname": "sort_file", "kind": "function", "doc": "<p>Sorts the lines of a file alphabetically.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>file_path:</strong>  The file to be sorted.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_gcam", "modulename": "utility_gcam", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "utility_gcam.forest_names", "modulename": "utility_gcam", "qualname": "forest_names", "kind": "variable", "doc": "<p></p>\n", "default_value": "[&#x27;Forest&#x27;, &#x27;ProtectedUnmanagedForest&#x27;, &#x27;UnmanagedForest&#x27;]"}, {"fullname": "utility_gcam.pasture_names", "modulename": "utility_gcam", "qualname": "pasture_names", "kind": "variable", "doc": "<p></p>\n", "default_value": "[&#x27;Pasture&#x27;, &#x27;UnmanagedPasture&#x27;, &#x27;ProtectedUnmanagedPasture&#x27;]"}, {"fullname": "utility_gcam.grassland_names", "modulename": "utility_gcam", "qualname": "grassland_names", "kind": "variable", "doc": "<p></p>\n", "default_value": "[&#x27;Grassland&#x27;, &#x27;ProtectedGrassland&#x27;]"}, {"fullname": "utility_gcam.crop_names_nonstandard", "modulename": "utility_gcam", "qualname": "crop_names_nonstandard", "kind": "variable", "doc": "<p></p>\n", "default_value": "[&#x27;Corn&#x27;, &#x27;CornC4&#x27;, &#x27;FiberCrop&#x27;, &#x27;FodderGrass&#x27;, &#x27;FodderHerb&#x27;, &#x27;FodderHerbC4&#x27;, &#x27;Fruits&#x27;, &#x27;FruitsTree&#x27;, &#x27;Legumes&#x27;, &#x27;MiscCrop&#x27;, &#x27;MiscCropC4&#x27;, &#x27;MiscCropTree&#x27;, &#x27;NutsSeeds&#x27;, &#x27;NutsSeedsTree&#x27;, &#x27;OilCrop&#x27;, &#x27;OilCropTree&#x27;, &#x27;OilPalmTree&#x27;, &#x27;OtherGrain&#x27;, &#x27;OtherGrainC4&#x27;, &#x27;Rice&#x27;, &#x27;RootTuber&#x27;, &#x27;Soybean&#x27;, &#x27;SugarCrop&#x27;, &#x27;SugarCropC4&#x27;, &#x27;Vegetables&#x27;, &#x27;Wheat&#x27;, &#x27;biomass&#x27;, &#x27;biomassGrass&#x27;, &#x27;biomassTree&#x27;]"}, {"fullname": "utility_gcam.crop_names", "modulename": "utility_gcam", "qualname": "crop_names", "kind": "variable", "doc": "<p></p>\n", "default_value": "[&#x27;BioenergyCrop&#x27;, &#x27;Corn&#x27;, &#x27;FiberCrop&#x27;, &#x27;FodderGrass&#x27;, &#x27;FodderHerb&#x27;, &#x27;FodderHerb&#x27;, &#x27;Fruits&#x27;, &#x27;Legumes&#x27;, &#x27;MiscCrop&#x27;, &#x27;NutsSeeds&#x27;, &#x27;OilCrop&#x27;, &#x27;OilPalm&#x27;, &#x27;OtherGrain&#x27;, &#x27;Rice&#x27;, &#x27;RootTuber&#x27;, &#x27;Soybean&#x27;, &#x27;SugarCrop&#x27;, &#x27;Vegetables&#x27;, &#x27;Wheat&#x27;]"}, {"fullname": "utility_gcam.other_arable_names", "modulename": "utility_gcam", "qualname": "other_arable_names", "kind": "variable", "doc": "<p></p>\n", "default_value": "[&#x27;OtherArableLand&#x27;]"}, {"fullname": "utility_gcam.shrubland_names", "modulename": "utility_gcam", "qualname": "shrubland_names", "kind": "variable", "doc": "<p></p>\n", "default_value": "[&#x27;Shrubland&#x27;, &#x27;ProtectedShrubland&#x27;]"}, {"fullname": "utility_gcam.urban_names", "modulename": "utility_gcam", "qualname": "urban_names", "kind": "variable", "doc": "<p></p>\n", "default_value": "[&#x27;UrbanLand&#x27;]"}, {"fullname": "utility_gcam.other_names", "modulename": "utility_gcam", "qualname": "other_names", "kind": "variable", "doc": "<p>Dictionary of GCAM land type groups and aggregations with standard crop names.</p>\n", "default_value": "[&#x27;RockIceDesert&#x27;, &#x27;Tundra&#x27;]"}, {"fullname": "utility_gcam.gcam_landtype_groups", "modulename": "utility_gcam", "qualname": "gcam_landtype_groups", "kind": "variable", "doc": "<p>Dictionary of GCAM land type groups and aggregations with nonstandard crop names.</p>\n", "default_value": "{&#x27;forest&#x27;: [&#x27;Forest&#x27;, &#x27;ProtectedUnmanagedForest&#x27;, &#x27;UnmanagedForest&#x27;], &#x27;pasture&#x27;: [&#x27;Pasture&#x27;, &#x27;UnmanagedPasture&#x27;, &#x27;ProtectedUnmanagedPasture&#x27;], &#x27;grass&#x27;: [&#x27;Grassland&#x27;, &#x27;ProtectedGrassland&#x27;], &#x27;crop&#x27;: [&#x27;Corn&#x27;, &#x27;CornC4&#x27;, &#x27;FiberCrop&#x27;, &#x27;FodderGrass&#x27;, &#x27;FodderHerb&#x27;, &#x27;FodderHerbC4&#x27;, &#x27;Fruits&#x27;, &#x27;FruitsTree&#x27;, &#x27;Legumes&#x27;, &#x27;MiscCrop&#x27;, &#x27;MiscCropC4&#x27;, &#x27;MiscCropTree&#x27;, &#x27;NutsSeeds&#x27;, &#x27;NutsSeedsTree&#x27;, &#x27;OilCrop&#x27;, &#x27;OilCropTree&#x27;, &#x27;OilPalmTree&#x27;, &#x27;OtherGrain&#x27;, &#x27;OtherGrainC4&#x27;, &#x27;Rice&#x27;, &#x27;RootTuber&#x27;, &#x27;Soybean&#x27;, &#x27;SugarCrop&#x27;, &#x27;SugarCropC4&#x27;, &#x27;Vegetables&#x27;, &#x27;Wheat&#x27;, &#x27;biomass&#x27;, &#x27;biomassGrass&#x27;, &#x27;biomassTree&#x27;], &#x27;other_arable&#x27;: [&#x27;OtherArableLand&#x27;], &#x27;shrub&#x27;: [&#x27;Shrubland&#x27;, &#x27;ProtectedShrubland&#x27;], &#x27;urban&#x27;: [&#x27;UrbanLand&#x27;], &#x27;other&#x27;: [&#x27;RockIceDesert&#x27;, &#x27;Tundra&#x27;]}"}, {"fullname": "utility_gcam.gcam_landtype_groups_nonstandard", "modulename": "utility_gcam", "qualname": "gcam_landtype_groups_nonstandard", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;forest&#x27;: [&#x27;Forest&#x27;, &#x27;ProtectedUnmanagedForest&#x27;, &#x27;UnmanagedForest&#x27;], &#x27;pasture&#x27;: [&#x27;Pasture&#x27;, &#x27;UnmanagedPasture&#x27;, &#x27;ProtectedUnmanagedPasture&#x27;], &#x27;grass&#x27;: [&#x27;Grassland&#x27;, &#x27;ProtectedGrassland&#x27;], &#x27;crop&#x27;: [&#x27;Corn&#x27;, &#x27;CornC4&#x27;, &#x27;FiberCrop&#x27;, &#x27;FodderGrass&#x27;, &#x27;FodderHerb&#x27;, &#x27;FodderHerbC4&#x27;, &#x27;Fruits&#x27;, &#x27;FruitsTree&#x27;, &#x27;Legumes&#x27;, &#x27;MiscCrop&#x27;, &#x27;MiscCropC4&#x27;, &#x27;MiscCropTree&#x27;, &#x27;NutsSeeds&#x27;, &#x27;NutsSeedsTree&#x27;, &#x27;OilCrop&#x27;, &#x27;OilCropTree&#x27;, &#x27;OilPalmTree&#x27;, &#x27;OtherGrain&#x27;, &#x27;OtherGrainC4&#x27;, &#x27;Rice&#x27;, &#x27;RootTuber&#x27;, &#x27;Soybean&#x27;, &#x27;SugarCrop&#x27;, &#x27;SugarCropC4&#x27;, &#x27;Vegetables&#x27;, &#x27;Wheat&#x27;, &#x27;biomass&#x27;, &#x27;biomassGrass&#x27;, &#x27;biomassTree&#x27;], &#x27;other_arable&#x27;: [&#x27;OtherArableLand&#x27;], &#x27;shrub&#x27;: [&#x27;Shrubland&#x27;, &#x27;ProtectedShrubland&#x27;], &#x27;urban&#x27;: [&#x27;UrbanLand&#x27;], &#x27;other&#x27;: [&#x27;RockIceDesert&#x27;, &#x27;Tundra&#x27;]}"}, {"fullname": "utility_gcam.gcam_crop_names", "modulename": "utility_gcam", "qualname": "gcam_crop_names", "kind": "variable", "doc": "<p>Dictionary of GCAM basin names (keys) and their abbreviations (values).</p>\n", "default_value": "{&#x27;biomass&#x27;: &#x27;BioenergyCrop&#x27;, &#x27;biomassGrass&#x27;: &#x27;BioenergyCrop&#x27;, &#x27;biomassTree&#x27;: &#x27;BioenergyCrop&#x27;, &#x27;CornC4&#x27;: &#x27;Corn&#x27;, &#x27;FodderHerbC4&#x27;: &#x27;FodderHerb&#x27;, &#x27;FruitsTree&#x27;: &#x27;Fruits&#x27;, &#x27;MiscCropTree&#x27;: &#x27;MiscCrop&#x27;, &#x27;MiscCropC4&#x27;: &#x27;MiscCrop&#x27;, &#x27;NutsSeedsTree&#x27;: &#x27;NutsSeeds&#x27;, &#x27;OilCropTree&#x27;: &#x27;OilCrop&#x27;, &#x27;OilPalmTree&#x27;: &#x27;OilPalm&#x27;, &#x27;OtherGrainC4&#x27;: &#x27;OtherGrain&#x27;, &#x27;SugarCropC4&#x27;: &#x27;SugarCrop&#x27;}"}, {"fullname": "utility_gcam.gcam_basin_names_and_abbrevations", "modulename": "utility_gcam", "qualname": "gcam_basin_names_and_abbrevations", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;Africa_East_Central_Coast&#x27;: &#x27;AfrCstE&#x27;, &#x27;Africa_Red_Sea_Gulf_of_Aden_Coast&#x27;: &#x27;AfrCstNE&#x27;, &#x27;Africa_North_Interior&#x27;: &#x27;AfrIntN&#x27;, &#x27;Congo&#x27;: &#x27;CongoR&#x27;, &#x27;Lake_Chad&#x27;: &#x27;LChad&#x27;, &#x27;Madagascar&#x27;: &#x27;Madagascar&#x27;, &#x27;Nile&#x27;: &#x27;NileR&#x27;, &#x27;Rift_Valley&#x27;: &#x27;RiftValley&#x27;, &#x27;Shebelli_Juba&#x27;: &#x27;ShebJubR&#x27;, &#x27;Africa_North_West_Coast&#x27;: &#x27;AfrCstNW&#x27;, &#x27;Dead_Sea&#x27;: &#x27;DeadSea&#x27;, &#x27;Mediterranean_Sea_East_Coast&#x27;: &#x27;MeditE&#x27;, &#x27;Mediterranean_South_Coast&#x27;: &#x27;MeditS&#x27;, &#x27;Niger&#x27;: &#x27;NigerR&#x27;, &#x27;Sinai_Peninsula&#x27;: &#x27;SinaiP&#x27;, &#x27;Africa_Indian_Ocean_Coast&#x27;: &#x27;AfrCstSE&#x27;, &#x27;Namibia_Coast&#x27;: &#x27;AfrCstSW&#x27;, &#x27;South_Africa_South_Coast&#x27;: &#x27;AfrCstS&#x27;, &#x27;Africa_South_Interior&#x27;: &#x27;AfrIntS&#x27;, &#x27;Angola_Coast&#x27;: &#x27;AngolaCst&#x27;, &#x27;Gulf_of_Guinea&#x27;: &#x27;GuineaGulf&#x27;, &#x27;Limpopo&#x27;: &#x27;LimpopoR&#x27;, &#x27;Orange&#x27;: &#x27;OrangeR&#x27;, &#x27;Zambezi&#x27;: &#x27;ZambeziR&#x27;, &#x27;Africa_West_Coast&#x27;: &#x27;AfrCstW&#x27;, &#x27;Senegal&#x27;: &#x27;SenegalR&#x27;, &#x27;Volta&#x27;: &#x27;VoltaR&#x27;, &#x27;South_America_Colorado&#x27;: &#x27;ArgColoR&#x27;, &#x27;North_Argentina_South_Atlantic_Coast&#x27;: &#x27;ArgCstN&#x27;, &#x27;South_Argentina_South_Atlantic_Coast&#x27;: &#x27;ArgCstS&#x27;, &#x27;North_Chile_Pacific_Coast&#x27;: &#x27;ChileCstN&#x27;, &#x27;South_Chile_Pacific_Coast&#x27;: &#x27;ChileCstS&#x27;, &#x27;La_Puna_Region&#x27;: &#x27;LaPuna&#x27;, &#x27;Mar_Chiquita&#x27;: &#x27;MarChiq&#x27;, &#x27;Negro&#x27;: &#x27;NegroR&#x27;, &#x27;Pampas_Region&#x27;: &#x27;Pampas&#x27;, &#x27;Central_Patagonia_Highlands&#x27;: &#x27;Patagonia&#x27;, &#x27;La_Plata&#x27;: &#x27;RioLaPlata&#x27;, &#x27;Salinas_Grandes&#x27;: &#x27;Salinas&#x27;, &#x27;Australia_East_Coast&#x27;: &#x27;AusCstE&#x27;, &#x27;Australia_North_Coast&#x27;: &#x27;AusCstN&#x27;, &#x27;Australia_South_Coast&#x27;: &#x27;AusCstS&#x27;, &#x27;Australia_West_Coast&#x27;: &#x27;AusCstW&#x27;, &#x27;Australia_Interior&#x27;: &#x27;AusInt&#x27;, &#x27;Murray_Darling&#x27;: &#x27;MurrayDrlg&#x27;, &#x27;New_Zealand&#x27;: &#x27;NewZealand&#x27;, &#x27;Tasmania&#x27;: &#x27;Tasmania&#x27;, &#x27;Amazon&#x27;: &#x27;AmazonR&#x27;, &#x27;East_Brazil_South_Atlantic_Coast&#x27;: &#x27;BrzCstE&#x27;, &#x27;North_Brazil_South_Atlantic_Coast&#x27;: &#x27;BrzCstN&#x27;, &#x27;Uruguay_Brazil_South_Atlantic_Coast&#x27;: &#x27;BrzCstS&#x27;, &#x27;Orinoco&#x27;: &#x27;OrinocoR&#x27;, &#x27;Parnaiba&#x27;: &#x27;ParnaibaR&#x27;, &#x27;Northeast_South_America_South_Atlantic_Coast&#x27;: &#x27;SAmerCstNE&#x27;, &#x27;Sao_Francisco&#x27;: &#x27;SaoFrancR&#x27;, &#x27;Tocantins&#x27;: &#x27;TocantinsR&#x27;, &#x27;Atlantic_Ocean_Seaboard&#x27;: &#x27;CanAtl&#x27;, &#x27;Churchill&#x27;: &#x27;ChurchillR&#x27;, &#x27;Fraser&#x27;: &#x27;FraserR&#x27;, &#x27;Great_Lakes_Basin&#x27;: &#x27;GreatLakes&#x27;, &#x27;Hudson_Bay_Coast&#x27;: &#x27;HudsonBay&#x27;, &#x27;Mackenzie&#x27;: &#x27;Mackenzie&#x27;, &#x27;Missouri_River_Basin&#x27;: &#x27;MissouriR&#x27;, &#x27;Northwest_Territories&#x27;: &#x27;NWTerr&#x27;, &#x27;Saskatchewan_Nelson&#x27;: &#x27;NelsonR&#x27;, &#x27;Pacific_and_Arctic_Coast&#x27;: &#x27;PacArctic&#x27;, &#x27;St_Lawrence&#x27;: &#x27;StLwrncR&#x27;, &#x27;New_England_Basin&#x27;: &#x27;UsaCstNE&#x27;, &#x27;Pacific_Northwest_Basin&#x27;: &#x27;UsaPacNW&#x27;, &#x27;Caribbean&#x27;: &#x27;Caribbean&#x27;, &#x27;Southern_Central_America&#x27;: &#x27;CntAmer&#x27;, &#x27;Colombia_Ecuador_Pacific_Coast&#x27;: &#x27;ColEcuaCst&#x27;, &#x27;Grijalva_Usumacinta&#x27;: &#x27;GrijUsuR&#x27;, &#x27;Caribbean_Coast&#x27;: &#x27;SAmerCstN&#x27;, &#x27;Yucatan_Peninsula&#x27;: &#x27;YucatanP&#x27;, &#x27;Amu_Darya&#x27;: &#x27;AmuDaryaR&#x27;, &#x27;Amur&#x27;: &#x27;AmurR&#x27;, &#x27;Black_Sea_North_Coast&#x27;: &#x27;BlackSeaN&#x27;, &#x27;Black_Sea_South_Coast&#x27;: &#x27;BlackSeaS&#x27;, &#x27;Caspian_Sea_East_Coast&#x27;: &#x27;CaspianE&#x27;, &#x27;Caspian_Sea_Coast&#x27;: &#x27;CaspianNE&#x27;, &#x27;Caspian_Sea_South_West_Coast&#x27;: &#x27;CaspianSW&#x27;, &#x27;Gobi_Interior&#x27;: &#x27;Gobi&#x27;, &#x27;Lake_Balkash&#x27;: &#x27;LBalkash&#x27;, &#x27;Ob&#x27;: &#x27;ObR&#x27;, &#x27;Syr_Darya&#x27;: &#x27;SyrDaryaR&#x27;, &#x27;Tarim_Interior&#x27;: &#x27;Tarim&#x27;, &#x27;Ural&#x27;: &#x27;UralR&#x27;, &#x27;Volga&#x27;: &#x27;VolgaR&#x27;, &#x27;Yenisei&#x27;: &#x27;YeniseiR&#x27;, &#x27;Bo_Hai_Korean_Bay_North_Coast&#x27;: &#x27;BoHai&#x27;, &#x27;China_Coast&#x27;: &#x27;ChinaCst&#x27;, &#x27;Ganges_Bramaputra&#x27;: &#x27;GangesR&#x27;, &#x27;Hainan&#x27;: &#x27;Hainan&#x27;, &#x27;Hong_(Red_River)&#x27;: &#x27;Hong&#x27;, &#x27;Huang_He&#x27;: &#x27;HuangHeR&#x27;, &#x27;Indus&#x27;: &#x27;IndusR&#x27;, &#x27;Irrawaddy&#x27;: &#x27;IrrawaddyR&#x27;, &#x27;Mekong&#x27;: &#x27;Mekong&#x27;, &#x27;Russia_South_East_Coast&#x27;: &#x27;RusCstSE&#x27;, &#x27;South_China_Sea_Coast&#x27;: &#x27;SChinaSea&#x27;, &#x27;Salween&#x27;: &#x27;Salween&#x27;, &#x27;Plateau_of_Tibet_Interior&#x27;: &#x27;Tibet&#x27;, &#x27;Xun_Jiang&#x27;: &#x27;XunJiang&#x27;, &#x27;Yangtze&#x27;: &#x27;Yangtze&#x27;, &#x27;Ziya_He_Interior&#x27;: &#x27;ZiyaHe&#x27;, &#x27;Magdalena&#x27;: &#x27;MagdalenaR&#x27;, &#x27;Adriatic_Sea_Greece_Black_Sea_Coast&#x27;: &#x27;AdrBlkSea&#x27;, &#x27;Baltic_Sea_Coast&#x27;: &#x27;BalticSea&#x27;, &#x27;Danube&#x27;: &#x27;DanubeR&#x27;, &#x27;Daugava&#x27;: &#x27;DaugavaR&#x27;, &#x27;Dniester&#x27;: &#x27;DniesterR&#x27;, &#x27;Denmark_Germany_Coast&#x27;: &#x27;DnkGrmCst&#x27;, &#x27;Elbe&#x27;: &#x27;ElbeR&#x27;, &#x27;Narva&#x27;: &#x27;NarvaR&#x27;, &#x27;Neman&#x27;: &#x27;NemanR&#x27;, &#x27;Oder&#x27;: &#x27;OderR&#x27;, &#x27;Poland_Coast&#x27;: &#x27;PolandCst&#x27;, &#x27;Wisla&#x27;: &#x27;WislaR&#x27;, &#x27;Arctic_Ocean_Islands&#x27;: &#x27;ArcticIsl&#x27;, &#x27;Douro&#x27;: &#x27;DouroR&#x27;, &#x27;Ebro&#x27;: &#x27;EbroR&#x27;, &#x27;Ems_Weser&#x27;: &#x27;EmsWeserR&#x27;, &#x27;England_and_Wales&#x27;: &#x27;EngWales&#x27;, &#x27;Finland&#x27;: &#x27;Finland&#x27;, &#x27;France_South_Coast&#x27;: &#x27;FranceCstS&#x27;, &#x27;France_West_Coast&#x27;: &#x27;FranceCstW&#x27;, &#x27;Gironde&#x27;: &#x27;Gironde&#x27;, &#x27;Guadalquivir&#x27;: &#x27;GuadalqR&#x27;, &#x27;Guadiana&#x27;: &#x27;GuadianaR&#x27;, &#x27;Spain_Portugal_Atlantic_Coast&#x27;: &#x27;IberiaCst&#x27;, &#x27;Ireland&#x27;: &#x27;Ireland&#x27;, &#x27;Italy_East_Coast&#x27;: &#x27;ItalyCstE&#x27;, &#x27;Italy_West_Coast&#x27;: &#x27;ItalyCstW&#x27;, &#x27;Loire&#x27;: &#x27;LoireR&#x27;, &#x27;Mediterranean_Sea_Islands&#x27;: &#x27;MeditIsl&#x27;, &#x27;Neva&#x27;: &#x27;NevaR&#x27;, &#x27;Po&#x27;: &#x27;PoR&#x27;, &#x27;Rhine&#x27;: &#x27;RhineR&#x27;, &#x27;Rhone&#x27;: &#x27;RhoneR&#x27;, &#x27;Scheldt&#x27;: &#x27;ScheldtR&#x27;, &#x27;Scandinavia_North_Coast&#x27;: &#x27;ScndnvN&#x27;, &#x27;Scotland&#x27;: &#x27;Scotland&#x27;, &#x27;Seine&#x27;: &#x27;SeineR&#x27;, &#x27;Spain_South_and_East_Coast&#x27;: &#x27;SpainCstSE&#x27;, &#x27;Sweden&#x27;: &#x27;Sweden&#x27;, &#x27;Tagus&#x27;: &#x27;TagusR&#x27;, &#x27;Tiber&#x27;: &#x27;TiberR&#x27;, &#x27;Dnieper&#x27;: &#x27;DnieperR&#x27;, &#x27;Don&#x27;: &#x27;DonR&#x27;, &#x27;Eastern_Jordan_Syria&#x27;: &#x27;EJrdnSyr&#x27;, &#x27;Tigris_Euphrates&#x27;: &#x27;TigrEuphR&#x27;, &#x27;Iceland&#x27;: &#x27;Iceland&#x27;, &#x27;Andaman_Nicobar_Islands&#x27;: &#x27;AdnNicIsl&#x27;, &#x27;Bay_of_Bengal_North_East_Coast&#x27;: &#x27;BengalBay&#x27;, &#x27;Yasai&#x27;: &#x27;BengalW&#x27;, &#x27;Brahmani&#x27;: &#x27;BrahmaniR&#x27;, &#x27;Cauvery&#x27;: &#x27;CauveryR&#x27;, &#x27;Godavari&#x27;: &#x27;GodavariR&#x27;, &#x27;India_East_Coast&#x27;: &#x27;IndCstE&#x27;, &#x27;India_North_East_Coast&#x27;: &#x27;IndCstNE&#x27;, &#x27;India_South_Coast&#x27;: &#x27;IndCstS&#x27;, &#x27;India_West_Coast&#x27;: &#x27;IndCstW&#x27;, &#x27;Krishna&#x27;: &#x27;KrishnaR&#x27;, &#x27;Mahanadi&#x27;: &#x27;MahanadiR&#x27;, &#x27;Mahi&#x27;: &#x27;MahiR&#x27;, &#x27;Narmada&#x27;: &#x27;NarmadaR&#x27;, &#x27;Pennar&#x27;: &#x27;PennarR&#x27;, &#x27;Sabarmati&#x27;: &#x27;SabarmatiR&#x27;, &#x27;Tapti&#x27;: &#x27;TaptiR&#x27;, &#x27;North_Borneo_Coast&#x27;: &#x27;BorneoCstN&#x27;, &#x27;Fly&#x27;: &#x27;FlyR&#x27;, &#x27;Palau_and_East_Indonesia&#x27;: &#x27;IdnE&#x27;, &#x27;Irian_Jaya_Coast&#x27;: &#x27;IrianJaya&#x27;, &#x27;Java_Timor&#x27;: &#x27;JavaTimor&#x27;, &#x27;Kalimantan&#x27;: &#x27;Kalimantan&#x27;, &#x27;Sepik&#x27;: &#x27;SepikR&#x27;, &#x27;Sulawesi&#x27;: &#x27;Sulawesi&#x27;, &#x27;Sumatra&#x27;: &#x27;Sumatra&#x27;, &#x27;Japan&#x27;: &#x27;Japan&#x27;, &#x27;Taiwan&#x27;: &#x27;Taiwan&#x27;, &#x27;California_River_Basin&#x27;: &#x27;California&#x27;, &#x27;Baja_California&#x27;: &#x27;MexBaja&#x27;, &#x27;Mexico_Northwest_Coast&#x27;: &#x27;MexCstNW&#x27;, &#x27;Pacific_Central_Coast&#x27;: &#x27;MexCstW&#x27;, &#x27;North_Gulf&#x27;: &#x27;MexGulf&#x27;, &#x27;Mexico_Interior&#x27;: &#x27;MexInt&#x27;, &#x27;Papaloapan&#x27;: &#x27;Papaloapan&#x27;, &#x27;Rio_Balsas&#x27;: &#x27;RioBalsas&#x27;, &#x27;Rio_Grande_River_Basin&#x27;: &#x27;RioGrande&#x27;, &#x27;Rio_Lerma&#x27;: &#x27;RioLerma&#x27;, &#x27;Rio_Verde&#x27;: &#x27;RioVerde&#x27;, &#x27;Isthmus_of_Tehuantepec&#x27;: &#x27;Tehuantpc&#x27;, &#x27;Lower_Colorado_River_Basin&#x27;: &#x27;UsaColoRS&#x27;, &#x27;Arabian_Peninsula&#x27;: &#x27;ArabianP&#x27;, &#x27;Arabian_Sea_Coast&#x27;: &#x27;ArabianSea&#x27;, &#x27;Farahrud&#x27;: &#x27;FarahrudR&#x27;, &#x27;HamuniMashkel&#x27;: &#x27;HamuMashR&#x27;, &#x27;Helmand&#x27;: &#x27;Helmand&#x27;, &#x27;Central_Iran&#x27;: &#x27;Iran&#x27;, &#x27;Persian_Gulf_Coast&#x27;: &#x27;PersianGulf&#x27;, &#x27;Red_Sea_East_Coast&#x27;: &#x27;RedSeaE&#x27;, &#x27;Russia_Barents_Sea_Coast&#x27;: &#x27;BarentsSea&#x27;, &#x27;Northern_Dvina&#x27;: &#x27;DvinaRN&#x27;, &#x27;Kara_Sea_Coast&#x27;: &#x27;KaraSea&#x27;, &#x27;Lena&#x27;: &#x27;LenaR&#x27;, &#x27;Siberia_North_Coast&#x27;: &#x27;SiberiaN&#x27;, &#x27;Siberia_West_Coast&#x27;: &#x27;SiberiaW&#x27;, &#x27;South_Africa_West_Coast&#x27;: &#x27;AfrCstSSW&#x27;, &#x27;Peru_Pacific_Coast&#x27;: &#x27;PeruCst&#x27;, &#x27;Sri_Lanka&#x27;: &#x27;SriLanka&#x27;, &#x27;North_and_South_Korea&#x27;: &#x27;Korea&#x27;, &#x27;Chao_Phraya&#x27;: &#x27;ChaoPhrR&#x27;, &#x27;Peninsula_Malaysia&#x27;: &#x27;MalaysiaP&#x27;, &#x27;South_Pacific_Islands&#x27;: &#x27;NewCaledn&#x27;, &#x27;Papua_New_Guinea_Coast&#x27;: &#x27;PapuaCst&#x27;, &#x27;Philippines&#x27;: &#x27;Phlppns&#x27;, &#x27;Sittaung&#x27;: &#x27;SittaungR&#x27;, &#x27;Solomon_Islands&#x27;: &#x27;SolomonIsl&#x27;, &#x27;Gulf_of_Thailand_Coast&#x27;: &#x27;ThaiGulf&#x27;, &#x27;Viet_Nam_Coast&#x27;: &#x27;VietnamCst&#x27;, &#x27;Arkansas_White_Red_Basin&#x27;: &#x27;ArkWhtRedR&#x27;, &#x27;Great_Basin&#x27;: &#x27;GreatBasin&#x27;, &#x27;Hawaii&#x27;: &#x27;Hawaii&#x27;, &#x27;Upper_Mississippi_Basin&#x27;: &#x27;MissppRN&#x27;, &#x27;Lower_Mississippi_River_Basin&#x27;: &#x27;MissppRS&#x27;, &#x27;Ohio_River_Basin&#x27;: &#x27;OhioR&#x27;, &#x27;Tennessee_River_Basin&#x27;: &#x27;TennR&#x27;, &#x27;Texas_Gulf_Coast_Basin&#x27;: &#x27;TexasCst&#x27;, &#x27;Upper_Colorado_River_Basin&#x27;: &#x27;UsaColoRN&#x27;, &#x27;Mid_Atlantic_Basin&#x27;: &#x27;UsaCstE&#x27;, &#x27;South_Atlantic_Gulf_Basin&#x27;: &#x27;UsaCstSE&#x27;}"}, {"fullname": "utility_gcam.produce_dataframe_for_landtype_group", "modulename": "utility_gcam", "qualname": "produce_dataframe_for_landtype_group", "kind": "function", "doc": "<p>Aggregates the rows of a given Pandas DataFrame that match the specified landtype_group (e.g., crop, forest, pasture, shrub, grass).\nPerforms one of four user-specified operations on the rows in the group: mean, sum, area-weighted mean, or area-weighted sum.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df:</strong>  DataFrame containing the data of interest.</li>\n<li><strong>category:</strong>  String specifying the name of the category of interest.</li>\n<li><strong>category_label:</strong>  String specifying the label for the appropriate category (e.g., 'sector' or 'landtype').</li>\n<li><strong>value_label:</strong>  String specifying the label for the column containing the value of interest.</li>\n<li><strong>landtype_groups:</strong>  Dictionary where the keys are landtype group names and the values are all the landtypes that belong to each group.</li>\n<li><strong>mean_or_sum_if_more_than_one_row_in_same_landtype_group:</strong>  String that indicates the operation that should be performed on each group.</li>\n<li><strong>key_columns:</strong>  Columns on which the aggregation (group-by) operation should be performed.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame with aggregated rows and the value_label column modified to reflect a mean, sum, area-weighted mean, or area-weighted sum.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">category</span>,</span><span class=\"param\">\t<span class=\"n\">category_label</span>,</span><span class=\"param\">\t<span class=\"n\">value_label</span>,</span><span class=\"param\">\t<span class=\"n\">landtype_groups</span>,</span><span class=\"param\">\t<span class=\"n\">mean_or_sum_if_more_than_one_row_in_same_landtype_group</span>,</span><span class=\"param\">\t<span class=\"n\">key_columns</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_gcam.standardize_crop_names", "modulename": "utility_gcam", "qualname": "standardize_crop_names", "kind": "function", "doc": "<p>Applies the mappings in gcam_crop_names to produce a common set of crop names in the given Pandas DataFrame.\nAn aggregation followed by a mean or sum is performed if there happens to be more than one row that matches a value for the given set of columns.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df:</strong>  DataFrame to modify.</li>\n<li><strong>columns:</strong>  Columns over which to perform the aggregation (group-by) operation.</li>\n<li><strong>mean_or_sum_if_more_than_one_row_for_crop_name:</strong>  Specifies whether to calculate a mean or a sum after performing the aggregation.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame with the crop names modified so that they belong to the standard common set.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">columns</span>, </span><span class=\"param\"><span class=\"n\">mean_or_sum_if_more_than_one_row_for_crop_name</span><span class=\"o\">=</span><span class=\"s1\">&#39;mean&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_plots", "modulename": "utility_plots", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "utility_plots.width_default", "modulename": "utility_plots", "qualname": "width_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "10"}, {"fullname": "utility_plots.height_default", "modulename": "utility_plots", "qualname": "height_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "8"}, {"fullname": "utility_plots.scale_default", "modulename": "utility_plots", "qualname": "scale_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;linear&#x27;"}, {"fullname": "utility_plots.axis_limits_default", "modulename": "utility_plots", "qualname": "axis_limits_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "None"}, {"fullname": "utility_plots.num_contour_levels_default", "modulename": "utility_plots", "qualname": "num_contour_levels_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "20"}, {"fullname": "utility_plots.axis_label_size_default", "modulename": "utility_plots", "qualname": "axis_label_size_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "24"}, {"fullname": "utility_plots.tick_label_size_default", "modulename": "utility_plots", "qualname": "tick_label_size_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "20"}, {"fullname": "utility_plots.legend_label_size_default", "modulename": "utility_plots", "qualname": "legend_label_size_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "14"}, {"fullname": "utility_plots.legend_num_columns_default", "modulename": "utility_plots", "qualname": "legend_num_columns_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "1"}, {"fullname": "utility_plots.legend_on_default", "modulename": "utility_plots", "qualname": "legend_on_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "True"}, {"fullname": "utility_plots.legend_place_outside_default", "modulename": "utility_plots", "qualname": "legend_place_outside_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "False"}, {"fullname": "utility_plots.linewidth_default", "modulename": "utility_plots", "qualname": "linewidth_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "2"}, {"fullname": "utility_plots.produce_png_default", "modulename": "utility_plots", "qualname": "produce_png_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "False"}, {"fullname": "utility_plots.use_latex_default", "modulename": "utility_plots", "qualname": "use_latex_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "False"}, {"fullname": "utility_plots.bbox_inches_default", "modulename": "utility_plots", "qualname": "bbox_inches_default", "kind": "variable", "doc": "<p>Hex codes of Matplotlib Tableau color palette: blue, orange, green, red, purple, brown, pink, gray, olive, cyan.</p>\n", "default_value": "&#x27;tight&#x27;"}, {"fullname": "utility_plots.plot_colors_default", "modulename": "utility_plots", "qualname": "plot_colors_default", "kind": "variable", "doc": "<p>XKCD colors (https://xkcd.com/color/rgb/): teal, magenta, sea green, bright pink, dark orange, goldenrod, forest, dirt, coral, baby blue, peach.</p>\n", "default_value": "[&#x27;#1f77b4&#x27;, &#x27;#ff7f0e&#x27;, &#x27;#2ca02c&#x27;, &#x27;#d62728&#x27;, &#x27;#9467bd&#x27;, &#x27;#8c564b&#x27;, &#x27;#e377c2&#x27;, &#x27;#7f7f7f&#x27;, &#x27;#bcbd22&#x27;, &#x27;#17becf&#x27;, &#x27;#029386&#x27;, &#x27;#c20078&#x27;, &#x27;#53fca1&#x27;, &#x27;#fe01b1&#x27;, &#x27;#c65102&#x27;, &#x27;#fac205&#x27;, &#x27;#0b5509&#x27;, &#x27;#8a6e45&#x27;, &#x27;#fc5a50&#x27;, &#x27;#a2cffe&#x27;, &#x27;#ffb07c&#x27;]"}, {"fullname": "utility_plots.linestyle_tuples_default", "modulename": "utility_plots", "qualname": "linestyle_tuples_default", "kind": "variable", "doc": "<p>Markers (https://matplotlib.org/stable/gallery/lines_bars_and_markers/marker_reference.html).</p>\n", "default_value": "[(&#x27;solid&#x27;, (0, ())), (&#x27;dashed&#x27;, (0, (5, 5))), (&#x27;dotted&#x27;, (0, (1, 5))), (&#x27;dashdot&#x27;, (0, (3, 5, 1, 5))), (&#x27;loosely dotted&#x27;, (0, (1, 10))), (&#x27;loosely dashed&#x27;, (0, (5, 10))), (&#x27;densely dashed&#x27;, (0, (5, 1))), (&#x27;loosely dashdotted&#x27;, (0, (3, 10, 1, 10))), (&#x27;densely dashdotted&#x27;, (0, (3, 1, 1, 1))), (&#x27;dashdotdotted&#x27;, (0, (3, 5, 1, 5, 1, 5))), (&#x27;loosely dashdotdotted&#x27;, (0, (3, 10, 1, 10, 1, 10))), (&#x27;densely dashdotdotted&#x27;, (0, (3, 1, 1, 1, 1, 1)))]"}, {"fullname": "utility_plots.markers_default", "modulename": "utility_plots", "qualname": "markers_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "[&#x27;o&#x27;, &#x27;v&#x27;, &#x27;^&#x27;, &#x27;&lt;&#x27;, &#x27;&gt;&#x27;, &#x27;8&#x27;, &#x27;s&#x27;, &#x27;p&#x27;, &#x27;*&#x27;, &#x27;h&#x27;, &#x27;H&#x27;, &#x27;D&#x27;, &#x27;d&#x27;, &#x27;P&#x27;, &#x27;X&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;+&#x27;, &#x27;x&#x27;, &#x27;|&#x27;]"}, {"fullname": "utility_plots.create_contour_plot", "modulename": "utility_plots", "qualname": "create_contour_plot", "kind": "function", "doc": "<p>Creates a contour plot.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x:</strong>  NumPy array or list containing the quantity to plot on the x axis.</li>\n<li><strong>y:</strong>  NumPy array or list containing the quantity to plot on the y axis.</li>\n<li><strong>z:</strong>  NumPy array or list containing the quantity to plot on the z axis.</li>\n<li><strong>options:</strong>  Dictionary that contains plotting options like number of contour levels or colorbar labels.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">z</span>, </span><span class=\"param\"><span class=\"n\">options</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_plots.save_figure", "modulename": "utility_plots", "qualname": "save_figure", "kind": "function", "doc": "<p>Saves a figure as either a .pdf (default) or .png (if figure name ends with .png or if produce_png in the options dictionary is True).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>name:</strong>  Name of the figure.</li>\n<li><strong>fig:</strong>  Object for the figure of interest.</li>\n<li><strong>options:</strong>  Dictionary that contains plotting options, including the value of produce_png.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name</span>, </span><span class=\"param\"><span class=\"n\">fig</span>, </span><span class=\"param\"><span class=\"n\">options</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_plots.set_figure_options", "modulename": "utility_plots", "qualname": "set_figure_options", "kind": "function", "doc": "<p>Sets options when creating a figure.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>fig:</strong>  Object for the figure of interest.</li>\n<li><strong>ax:</strong>  Axes object corresponding to the figure of interest. </li>\n<li><strong>options:</strong>  Dictionary that contains plotting options like x and y labels, the name of the figure, etc.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fig</span>, </span><span class=\"param\"><span class=\"n\">ax</span>, </span><span class=\"param\"><span class=\"n\">options</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_xarray", "modulename": "utility_xarray", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "utility_xarray.calculate_mean_and_std_of_da_list", "modulename": "utility_xarray", "qualname": "calculate_mean_and_std_of_da_list", "kind": "function", "doc": "<p>Calculates the mean of a list of xarray DataArrays and optionally also the standard deviation of this list.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>da_list:</strong>  A list of DataArrays with the same dimensions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A DataArray containing the mean of the input DataArrays and optionally also the standard deviation of this list.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">da_list</span>, </span><span class=\"param\"><span class=\"n\">calculate_std</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_xarray.calculate_statistics_of_xarray", "modulename": "utility_xarray", "qualname": "calculate_statistics_of_xarray", "kind": "function", "doc": "<p>Calculates the min, mean, median, max, and the standard deviation of an xarray or uxarray object (DataArray, Dataset, or uxarray data structure).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data:</strong>  Object of type xarray or uxarray whose statistical properties we want to calculate.</li>\n<li><strong>variable:</strong>  Variable of interest, used in the case of an xarray Dataset or uxarray data structure (UxDataArray or UxDataset).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>min, mean, median, max, and standard deviation of the xarray or uxarray object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">variable</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_xarray.convert_xarray_to_uxarray", "modulename": "utility_xarray", "qualname": "convert_xarray_to_uxarray", "kind": "function", "doc": "<p>Converts an xarray object (DataArray or Dataset) into an uxarray object (UxDataArray or UxDataset).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data:</strong>  Object of type xarray.</li>\n<li><strong>grid:</strong>  Grid object for the unstructured grid contained within the uxarray object.</li>\n<li><strong>variable:</strong>  Variable of interest.</li>\n<li><strong>fill_value:</strong>  Value to fill NaNs.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>uxarray (UxDataArray or UxDataset) version of the given xarray object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">grid</span>, </span><span class=\"param\"><span class=\"n\">variable</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">fillna</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();