window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "extract_spatial_data_E3SM_h0", "modulename": "extract_spatial_data_E3SM_h0", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "extract_spatial_data_E3SM_h0.process_inputs", "modulename": "extract_spatial_data_E3SM_h0", "qualname": "process_inputs", "kind": "function", "doc": "<p>Processes a dictionary of inputs (keys are options, values are choices for those options) for extracting spatial data from E3SM-generated NetCDF \nfiles and printing that data to smaller, focused NetCDF files that contain spatial data only for the variables specified in the dictionary.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>inputs:</strong>  Dictionary containing the user choice inputs for different options. This dictionary may be incomplete or have invalid values.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>List of dictionaries, where each dictionary has been processed so that it is complete in all options for a single focused NetCDF file.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "extract_spatial_data_E3SM_h0.process_dataset", "modulename": "extract_spatial_data_E3SM_h0", "qualname": "process_dataset", "kind": "function", "doc": "<p>Processes an xarray Dataset to add a total precipitation variable (including change units from m/s to mm/year) and \nadd a variable for the atmospheric mole fraction of CO2 in units of ppm.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>ds:</strong>  Dataset to process.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The processed Dataset.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ds</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "extract_spatial_data_E3SM_h0.extract_spatial_data_from_netcdf_files", "modulename": "extract_spatial_data_E3SM_h0", "qualname": "extract_spatial_data_from_netcdf_files", "kind": "function", "doc": "<p>Extracts time series data from E3SM-generated NetCDF files of a particular type that are located in a simulation directory and puts this data into\na smaller, focused NetCDF file that contains annual-mean spatial data only for the variables specified by the user in the inputs dictionary.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>input:</strong>  Dictionary containing the user data-extraction inputs for different options. This dictionary is assumed to be complete (pre-processed).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "extract_time_series_E3SM_h0", "modulename": "extract_time_series_E3SM_h0", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "extract_time_series_E3SM_h0.process_dataframe", "modulename": "extract_time_series_E3SM_h0", "qualname": "process_dataframe", "kind": "function", "doc": "<p>Processes a Pandas DataFrame by adding new columns (e.g., total precipitation, mole fraction CO2) or changing the units (e.g., Pg instead of g). </p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df:</strong>  DataFrame to be processed.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The processed DataFrame.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "extract_time_series_E3SM_h0.extract_netcdf_file_into_dataframe", "modulename": "extract_time_series_E3SM_h0", "qualname": "extract_netcdf_file_into_dataframe", "kind": "function", "doc": "<p>Extracts the specified variables from an E3SM-generated NetCDF file into a Pandas DataFrame and performs the indicated operation on the variables.\nEach NetCDF file contains simulation results for one month in a particular year from either EAM (atmosphere model) or ELM (land model). \nOne type of operation could be to perform an area-weighted mean over the latitude/longitude coordinates for the given month.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>file:</strong>  Complete path and name of the NetCDF file.</li>\n<li><strong>variables:</strong>  List of variables that we want to extract from the NetCDF file.</li>\n<li><strong>calculation_type:</strong>  String that indicates the operation type.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame containing one column for each of the variables, plus year and month columns.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file</span>, </span><span class=\"param\"><span class=\"n\">variables</span>, </span><span class=\"param\"><span class=\"n\">calculation_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;mean&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "extract_time_series_E3SM_h0.extract_time_series_from_netcdf_files", "modulename": "extract_time_series_E3SM_h0", "qualname": "extract_time_series_from_netcdf_files", "kind": "function", "doc": "<p>Extracts time series data from E3SM-generated NetCDF files in a simulation directory into a Pandas DataFrame and writes it to an output file. \nThe NetCDF files can be of more than one type (e.g., one set generated from the ELM model and another set from the EAM model in E3SM).\nEach NetCDF file contains simulation results for one month in a particular year.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>simulation_path:</strong>  Complete path of the directory containing the NetCDF output files from running a simulation.</li>\n<li><strong>output_file:</strong>  Name of the output file where the contents of the DataFrame will be written.</li>\n<li><strong>netcdf_substrings:</strong>  List where each element is itself a list of substrings. Each list corresponds to a particular type of NetCDF file and\nindicates the substrings that must be in the names of that NetCDF file type.</li>\n<li><strong>variables:</strong>  List where each element is itself a list of variables we want to extract for each type of NetCDF file. \nThe aggregate of all variables contained in these lists will together form the columns of the DataFrame.</li>\n<li><strong>calculation_types:</strong>  List of strings that indicate what type of calculation we want to perform to produce the time series data \nfor each type of NetCDF file. Current options include 'area_weighted_mean_or_sum', 'mean', and 'sum'.</li>\n<li><strong>process_variables:</strong>  Boolean indicating if further processing is to be done on the outputs in the DataFrame. This includes adding new variables\nnot in the NetCDF files (e.g., total precipitation, mole fraction CO2) or changing the units (e.g., Pg instead of g).</li>\n<li><strong>start_year:</strong>  First year in the extracted time series data.</li>\n<li><strong>end_year:</strong>  Last year in the extracted time series data.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">simulation_path</span>,</span><span class=\"param\">\t<span class=\"n\">output_file</span>,</span><span class=\"param\">\t<span class=\"n\">netcdf_substrings</span>,</span><span class=\"param\">\t<span class=\"n\">variables</span>,</span><span class=\"param\">\t<span class=\"n\">calculation_types</span>,</span><span class=\"param\">\t<span class=\"n\">process_variables</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">start_year</span><span class=\"o\">=</span><span class=\"mi\">2015</span>,</span><span class=\"param\">\t<span class=\"n\">end_year</span><span class=\"o\">=</span><span class=\"mi\">2100</span>,</span><span class=\"param\">\t<span class=\"n\">write_to_csv</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "extract_time_series_E3SM_surfdata_iESM_dyn", "modulename": "extract_time_series_E3SM_surfdata_iESM_dyn", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "extract_time_series_E3SM_surfdata_iESM_dyn.extract_dataframe_rows_for_given_year", "modulename": "extract_time_series_E3SM_surfdata_iESM_dyn", "qualname": "extract_dataframe_rows_for_given_year", "kind": "function", "doc": "<p>Processes the Pandas DataFrame so that it contains only the rows pertaining to the given year. Also changes the 'time' column to 'Year'.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df:</strong>  DataFrame of interest.</li>\n<li><strong>year:</strong>  Year of interest.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame containing only the rows for the given year, with the 'time' column changed to 'Year'.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">year</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "extract_time_series_E3SM_surfdata_iESM_dyn.extract_netcdf_file_into_dataframe_single_year", "modulename": "extract_time_series_E3SM_surfdata_iESM_dyn", "qualname": "extract_netcdf_file_into_dataframe_single_year", "kind": "function", "doc": "<p>For the given year, extracts the specified variables from the E3SM human component (EHC) land surface data file into a Pandas DataFrame. </p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>file:</strong>  NetCDF file generated by the EHC during run time. It contains data on land surface variables like harvest and grazing. </li>\n<li><strong>variables:</strong>  List of variables we want to extract from the NetCDF file. </li>\n<li><strong>year:</strong>  Year of interest.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame containing one column for each of the variables, plus a column for the specific year of interest.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file</span>, </span><span class=\"param\"><span class=\"n\">variables</span>, </span><span class=\"param\"><span class=\"n\">year</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "extract_time_series_E3SM_surfdata_iESM_dyn.extract_time_series_from_netcdf_file", "modulename": "extract_time_series_E3SM_surfdata_iESM_dyn", "qualname": "extract_time_series_from_netcdf_file", "kind": "function", "doc": "<p>Extracts the specified variables from an E3SM-generated NetCDF file into a Pandas DataFrame and performs the indicated operation on the variables.\nThis NetCDF file is generated dynamically during run time by the E3SM human component (EHC) and contains land surface data like harvest, grazing. </p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>inputs:</strong>  Dictionary containing the user choice inputs for different options, such as the variables that they want to extract from the file. </li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame containing one column for each of the variables, plus a column for the year.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "plot_spatial_data", "modulename": "plot_spatial_data", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "plot_spatial_data.default_inputs_spatial_data", "modulename": "plot_spatial_data", "qualname": "default_inputs_spatial_data", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;plot_directory&#x27;: &#x27;./&#x27;, &#x27;calculation_type&#x27;: &#x27;mean&#x27;, &#x27;plot_type_for_2_sets&#x27;: &#x27;absolute_difference&#x27;, &#x27;multiplier&#x27;: 1, &#x27;start_year&#x27;: 2071, &#x27;end_year&#x27;: 2090, &#x27;projection&#x27;: &lt;class &#x27;cartopy.crs.Robinson&#x27;&gt;, &#x27;cmap&#x27;: &#x27;bwr&#x27;, &#x27;width&#x27;: 10, &#x27;height&#x27;: 8, &#x27;cbar_on&#x27;: True, &#x27;cbar_label_size&#x27;: 20, &#x27;cbar_limits&#x27;: None, &#x27;cbar_x_offset&#x27;: 0.06, &#x27;title_size&#x27;: 24, &#x27;use_latex&#x27;: False, &#x27;produce_png&#x27;: False, &#x27;bbox_inches&#x27;: &#x27;tight&#x27;, &#x27;statistics_panel_size&#x27;: 14, &#x27;p_value_threshold&#x27;: 0.05, &#x27;p_value_file&#x27;: None, &#x27;p_value_file_print_only_if_below_threshold&#x27;: True, &#x27;stippling_on&#x27;: False, &#x27;stippling_std_multiple&#x27;: 2, &#x27;stippling_hatches&#x27;: &#x27;xxxx&#x27;, &#x27;grid_file&#x27;: None}"}, {"fullname": "plot_spatial_data.process_inputs", "modulename": "plot_spatial_data", "qualname": "process_inputs", "kind": "function", "doc": "<p>Processes a dictionary of inputs (keys are options, values are choices for those options) for creating spatial plots from data in NetCDF files.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>inputs:</strong>  Dictionary containing the user plotting choice inputs for different options. This dictionary may be incomplete or have invalid values.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>List of dictionaries, each of which specifies completed plotting options for a single variable. If the user did not select a plotting option \n  for a particular variable, the default choice for that plotting option will be selected.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "plot_spatial_data.plot_spatial_data_eam", "modulename": "plot_spatial_data", "qualname": "plot_spatial_data_eam", "kind": "function", "doc": "<p>Parses a dictionary of inputs (keys are options, values are choices for those options) to create spatial plots for a single variable from E3SM EAM\noutputs. The data for these spatial plots are stored in NetCDF files specified by the inputs dictionary.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>input:</strong>  Dictionary containing the user plotting choice inputs for different options. This dictionary is assumed to be complete (pre-processed).</li>\n<li><strong>grid_file:</strong>  Path and name of the grid file for the EAM unstructured mesh.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span>, </span><span class=\"param\"><span class=\"n\">grid_file</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "plot_spatial_data.plot_spatial_data_elm", "modulename": "plot_spatial_data", "qualname": "plot_spatial_data_elm", "kind": "function", "doc": "<p>Parses a dictionary of inputs (keys are options, values are choices for those options) to create spatial plots for a single variable from E3SM ELM\noutputs. The data for these spatial plots are stored in NetCDF files specified by the inputs dictionary.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>input:</strong>  Dictionary containing the user plotting choice inputs for different options. This dictionary is assumed to be complete (pre-processed).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "plot_spatial_data.plot_spatial_data_from_netcdf_files", "modulename": "plot_spatial_data", "qualname": "plot_spatial_data_from_netcdf_files", "kind": "function", "doc": "<p>Parses a dictionary of inputs (keys are options, values are choices for those options) to create spatial plots for a single variable from either \nE3SM atmosphere (EAM) or land (ELM) outputs. The data for these spatial plots are stored in NetCDF files specified by the inputs dictionary.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>input:</strong>  Dictionary containing the user plotting choice inputs for different options. This dictionary is assumed to be complete (pre-processed).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "plot_time_series", "modulename": "plot_time_series", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "plot_time_series.default_inputs_time_series", "modulename": "plot_time_series", "qualname": "default_inputs_time_series", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;plot_directory&#x27;: &#x27;./&#x27;, &#x27;calculation_type&#x27;: &#x27;mean&#x27;, &#x27;plot_type&#x27;: &#x27;ensemble_averages&#x27;, &#x27;plot_percent_difference&#x27;: False, &#x27;multiplier&#x27;: 1, &#x27;std_annual_multiplier&#x27;: 1, &#x27;std_seasons_multiplier&#x27;: None, &#x27;std_monthly_multiplier&#x27;: 1, &#x27;error_bars_alpha&#x27;: 0.2, &#x27;areas_in_thousands_km2&#x27;: True, &#x27;start_year&#x27;: 2015, &#x27;end_year&#x27;: 2100, &#x27;width&#x27;: 10, &#x27;height&#x27;: 8, &#x27;x_scale&#x27;: &#x27;linear&#x27;, &#x27;y_scale&#x27;: &#x27;linear&#x27;, &#x27;x_limits&#x27;: None, &#x27;y_limits&#x27;: None, &#x27;x_tick_label_size&#x27;: 20, &#x27;y_tick_label_size&#x27;: 20, &#x27;x_label_size&#x27;: 24, &#x27;y_label_size&#x27;: 24, &#x27;legend_label_size&#x27;: 14, &#x27;legend_on&#x27;: True, &#x27;linewidth&#x27;: 2, &#x27;plot_colors&#x27;: [&#x27;#1f77b4&#x27;, &#x27;#ff7f0e&#x27;, &#x27;#2ca02c&#x27;, &#x27;#d62728&#x27;, &#x27;#9467bd&#x27;, &#x27;#8c564b&#x27;, &#x27;#e377c2&#x27;, &#x27;#7f7f7f&#x27;, &#x27;#bcbd22&#x27;, &#x27;#17becf&#x27;], &#x27;linestyle_tuples&#x27;: [(&#x27;solid&#x27;, (0, ())), (&#x27;dashed&#x27;, (0, (5, 5))), (&#x27;dotted&#x27;, (0, (1, 5))), (&#x27;dashdot&#x27;, (0, (3, 5, 1, 5))), (&#x27;loosely dotted&#x27;, (0, (1, 10))), (&#x27;loosely dashed&#x27;, (0, (5, 10))), (&#x27;densely dashed&#x27;, (0, (5, 1))), (&#x27;loosely dashdotted&#x27;, (0, (3, 10, 1, 10))), (&#x27;densely dashdotted&#x27;, (0, (3, 1, 1, 1))), (&#x27;dashdotdotted&#x27;, (0, (3, 5, 1, 5, 1, 5))), (&#x27;loosely dashdotdotted&#x27;, (0, (3, 10, 1, 10, 1, 10))), (&#x27;densely dashdotdotted&#x27;, (0, (3, 1, 1, 1, 1, 1)))], &#x27;use_latex&#x27;: False, &#x27;produce_png&#x27;: False, &#x27;include_annual_mean_across_all_sets&#x27;: True, &#x27;include_monthly_mean_across_all_sets&#x27;: True, &#x27;std_annual_mean_across_all_sets_multiplier&#x27;: 1, &#x27;std_monthly_mean_across_all_sets_multiplier&#x27;: 1, &#x27;p_value_file&#x27;: None, &#x27;p_value_threshold&#x27;: 0.05, &#x27;p_value_file_print_only_if_below_threshold&#x27;: True, &#x27;p_value_marker&#x27;: &#x27;o&#x27;, &#x27;p_value_marker_size&#x27;: 6, &#x27;include_seasons&#x27;: {&#x27;MAM&#x27;: False, &#x27;JJA&#x27;: False, &#x27;SON&#x27;: False, &#x27;DJF&#x27;: False}, &#x27;seasons_to_plot_separately&#x27;: {&#x27;MAM&#x27;: False, &#x27;JJA&#x27;: False, &#x27;SON&#x27;: False, &#x27;DJF&#x27;: False}, &#x27;monthly_time_series_plot&#x27;: False, &#x27;monthly_time_series_start_year&#x27;: 2071, &#x27;monthly_time_series_end_year&#x27;: 2090, &#x27;monthly_time_series_x_limits&#x27;: None, &#x27;monthly_time_series_y_limits&#x27;: None}"}, {"fullname": "plot_time_series.process_inputs", "modulename": "plot_time_series", "qualname": "process_inputs", "kind": "function", "doc": "<p>Processes a dictionary of inputs (keys are options, values are choices for those options) for creating time series plots.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>inputs:</strong>  Dictionary containing the user plotting choice inputs for different options. This dictionary may be incomplete or have invalid values.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>List of dictionaries, each of which specifies all plotting options for a single variable. If the user did not select a plotting option for\n  a particular variable, the default choice for that plotting option will be selected.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "plot_time_series.plot_seasons", "modulename": "plot_time_series", "qualname": "plot_seasons", "kind": "function", "doc": "<p>Adds seasons (as specified in the include_seasons dictionary) to a given time series plot. </p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>include_seasons:</strong>  Dictionary specifying the seasons to include in the plot.</li>\n<li><strong>ax:</strong>  Axis object for the plot.</li>\n<li><strong>df:</strong>  Pandas DataFrame containing the time series data.</li>\n<li><strong>x:</strong>  Years to put on the x-axis.</li>\n<li><strong>output_label:</strong>  Base output label.</li>\n<li><strong>plot_colors:</strong>  List of plot line colors.</li>\n<li><strong>linestyle_tuples:</strong>  Tuples for the linestyles.</li>\n<li><strong>linewidth:</strong>  Thickness of the lines.</li>\n<li><strong>columns:</strong>  String (if a single column) or list (multiple columns) for the datasets in the DataFrame that we want to plot. \nIf a list, plot the mean across all columns.</li>\n<li><strong>reference_data:</strong>  Dictionary to store the data from the first file or first file set, which will serve as the reference set for \npercent difference calculations.</li>\n<li><strong>file_or_file_set_index:</strong>  Index for the particular file or file set, so that we can flag whether the current data pertain to the reference set.</li>\n<li><strong>std_multiplier:</strong>  Multiplier on the standard deviation for plotting error bars.</li>\n<li><strong>error_bars_alpha:</strong>  Opacity value for the error bars.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The reference_data, which will be updated with entries for the reference data for each season if this dictionary was not initially empty.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">include_seasons</span>,</span><span class=\"param\">\t<span class=\"n\">ax</span>,</span><span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">x</span>,</span><span class=\"param\">\t<span class=\"n\">output_label</span>,</span><span class=\"param\">\t<span class=\"n\">plot_colors</span>,</span><span class=\"param\">\t<span class=\"n\">linestyle_tuples</span>,</span><span class=\"param\">\t<span class=\"n\">linewidth</span>,</span><span class=\"param\">\t<span class=\"n\">columns</span>,</span><span class=\"param\">\t<span class=\"n\">reference_data</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">file_or_file_set_index</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">std_multiplier</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">error_bars_alpha</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "plot_time_series.read_file_into_single_variable_dataframe", "modulename": "plot_time_series", "qualname": "read_file_into_single_variable_dataframe", "kind": "function", "doc": "<p>Reads a file and puts the time series data for one specific variable from that file into a Pandas DataFrame. </p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>file:</strong>  Directory and name for the file we want to read.</li>\n<li><strong>variable:</strong>  The variable of interest.</li>\n<li><strong>start_year:</strong>  First year in the extracted time series data.</li>\n<li><strong>end_year:</strong>  Last year in the extracted time series data.</li>\n<li><strong>multiplier:</strong>  Multiplier on the time series (in case the user wants to change the units).</li>\n<li><strong>return_column:</strong>  Boolean that specifies if we want to additionally return the column in the DataFrame corresponding to the variable.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame containing the data for the variable and also the column in the DataFrame for that variable if return_column is True.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">file</span>,</span><span class=\"param\">\t<span class=\"n\">variable</span>,</span><span class=\"param\">\t<span class=\"n\">start_year</span>,</span><span class=\"param\">\t<span class=\"n\">end_year</span>,</span><span class=\"param\">\t<span class=\"n\">multiplier</span>,</span><span class=\"param\">\t<span class=\"n\">return_column</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "plot_time_series.read_file_set_into_single_variable_dataframe", "modulename": "plot_time_series", "qualname": "read_file_set_into_single_variable_dataframe", "kind": "function", "doc": "<p>Reads a list of output files and the time series data for one specific variable in those files into a Pandas DataFrame. </p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>output_files:</strong>  List of lists (2D matrix) for the files. We want to read in one column of this matrix, which corresponds to a particular group\nof files that we want to collect together into a set and later plot the various set means of a larger ensemble of sets.</li>\n<li><strong>file_set_index:</strong>  The column number for the output_files matrix. This indicates the index for the group/set of files that are of interest.</li>\n<li><strong>variable:</strong>  The variable of interest.</li>\n<li><strong>start_year:</strong>  First year in the extracted time series data.</li>\n<li><strong>end_year:</strong>  Last year in the extracted time series data.</li>\n<li><strong>multiplier:</strong>  Multiplier on the time series (in case the user wants to change the units).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame containing data from all files for the variable and also all DataFrame columns for the variable, one column from each of the files.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">output_files</span>,</span><span class=\"param\">\t<span class=\"n\">file_set_index</span>,</span><span class=\"param\">\t<span class=\"n\">variable</span>,</span><span class=\"param\">\t<span class=\"n\">start_year</span>,</span><span class=\"param\">\t<span class=\"n\">end_year</span>,</span><span class=\"param\">\t<span class=\"n\">multiplier</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "plot_time_series.plot_time_series", "modulename": "plot_time_series", "qualname": "plot_time_series", "kind": "function", "doc": "<p>Parses a dictionary of inputs (keys are options, values are choices for those options) to create time series plots for a single variable. \nTime series plots can be annual, with time presented in years (including seasonal variants that can be plotted separately), or \nmonthly, in which the values that are plotted indicate averages between specified start and end years for each month. \nTypes of plots: 1) Direct plots in which each output file is treated as an individual curve in the time series collection. 2) Ensemble plots in \nwhich the files are grouped into sets and averages of each set are plotted. Output files must be specified as a list of lists for ensemble plots.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>input:</strong>  Dictionary containing the user plotting choice inputs for different options. This dictionary is assumed to be complete (pre-processed).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "produce_synthetic_spatial_data", "modulename": "produce_synthetic_spatial_data", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "produce_synthetic_spatial_data.produce_synthetic_spatial_data", "modulename": "produce_synthetic_spatial_data", "qualname": "produce_synthetic_spatial_data", "kind": "function", "doc": "<p>Produces a synthetic set of spatial data using random numbers to introduce perturbations to the time series in a given file. Each new\nsynthetic spatial data map is output as a NetCDF file.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>inputs:</strong>  List with two items. The first item is the name of the file containing the base spatial data. \nThe second item is the total number of spatial data maps (including the base spatial data map) we want to include in the set.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "produce_synthetic_time_series", "modulename": "produce_synthetic_time_series", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "produce_synthetic_time_series.produce_synthetic_time_series", "modulename": "produce_synthetic_time_series", "qualname": "produce_synthetic_time_series", "kind": "function", "doc": "<p>Produces a synthetic set of time series using random numbers to introduce perturbations to the time series in a given file. Each new\nsynthetic time series is output as a .pdf or .csv file.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>inputs:</strong>  List with two items. The first item is the name of the file containing the base time series. \nThe second item is the total number of time series (including the base time series) we want to include in the set.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_constants", "modulename": "utility_constants", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "utility_constants.km_TO_m", "modulename": "utility_constants", "qualname": "km_TO_m", "kind": "variable", "doc": "<p></p>\n", "default_value": "1000.0"}, {"fullname": "utility_constants.km2_TO_m2", "modulename": "utility_constants", "qualname": "km2_TO_m2", "kind": "variable", "doc": "<p></p>\n", "default_value": "1000000.0"}, {"fullname": "utility_constants.days_TO_s", "modulename": "utility_constants", "qualname": "days_TO_s", "kind": "variable", "doc": "<p></p>\n", "default_value": "86400"}, {"fullname": "utility_constants.days_TO_hours", "modulename": "utility_constants", "qualname": "days_TO_hours", "kind": "variable", "doc": "<p></p>\n", "default_value": "24"}, {"fullname": "utility_constants.hours_TO_mins", "modulename": "utility_constants", "qualname": "hours_TO_mins", "kind": "variable", "doc": "<p></p>\n", "default_value": "60"}, {"fullname": "utility_constants.years_TO_days", "modulename": "utility_constants", "qualname": "years_TO_days", "kind": "variable", "doc": "<p></p>\n", "default_value": "365"}, {"fullname": "utility_constants.years_TO_s", "modulename": "utility_constants", "qualname": "years_TO_s", "kind": "variable", "doc": "<p></p>\n", "default_value": "31536000"}, {"fullname": "utility_constants.years_TO_months", "modulename": "utility_constants", "qualname": "years_TO_months", "kind": "variable", "doc": "<p></p>\n", "default_value": "12"}, {"fullname": "utility_constants.years_TO_hours", "modulename": "utility_constants", "qualname": "years_TO_hours", "kind": "variable", "doc": "<p></p>\n", "default_value": "8760"}, {"fullname": "utility_constants.years_TO_mins", "modulename": "utility_constants", "qualname": "years_TO_mins", "kind": "variable", "doc": "<p></p>\n", "default_value": "525600"}, {"fullname": "utility_constants.kg_TO_g", "modulename": "utility_constants", "qualname": "kg_TO_g", "kind": "variable", "doc": "<p></p>\n", "default_value": "1000.0"}, {"fullname": "utility_constants.Pg_TO_kg", "modulename": "utility_constants", "qualname": "Pg_TO_kg", "kind": "variable", "doc": "<p></p>\n", "default_value": "1000000000000.0"}, {"fullname": "utility_constants.Pg_TO_g", "modulename": "utility_constants", "qualname": "Pg_TO_g", "kind": "variable", "doc": "<p></p>\n", "default_value": "1000000000000000.0"}, {"fullname": "utility_constants.m_TO_mm", "modulename": "utility_constants", "qualname": "m_TO_mm", "kind": "variable", "doc": "<p></p>\n", "default_value": "1000.0"}, {"fullname": "utility_constants.mole_fraction_TO_ppm", "modulename": "utility_constants", "qualname": "mole_fraction_TO_ppm", "kind": "variable", "doc": "<p>Tiny constant used to avoid divide-by-zero errors.</p>\n", "default_value": "1000000.0"}, {"fullname": "utility_constants.EPSILON", "modulename": "utility_constants", "qualname": "EPSILON", "kind": "variable", "doc": "<p>Number of days and seconds in each month (no leap years).</p>\n", "default_value": "1e-14"}, {"fullname": "utility_constants.NUM_DAYS_IN_MONTHS", "modulename": "utility_constants", "qualname": "NUM_DAYS_IN_MONTHS", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31])"}, {"fullname": "utility_constants.NUM_SECONDS_IN_MONTHS", "modulename": "utility_constants", "qualname": "NUM_SECONDS_IN_MONTHS", "kind": "variable", "doc": "<p>Molar mass of carbon (g/mol).</p>\n", "default_value": "array([2678400, 2419200, 2678400, 2592000, 2678400, 2592000, 2678400,\n       2678400, 2592000, 2678400, 2592000, 2678400])"}, {"fullname": "utility_constants.MM_C", "modulename": "utility_constants", "qualname": "MM_C", "kind": "variable", "doc": "<p>Molar mass of CO2 (g/mol).</p>\n", "default_value": "12.011"}, {"fullname": "utility_constants.MM_CO2", "modulename": "utility_constants", "qualname": "MM_CO2", "kind": "variable", "doc": "<p>Molar mass of CH4 (g/mol).</p>\n", "default_value": "44.009"}, {"fullname": "utility_constants.MM_CH4", "modulename": "utility_constants", "qualname": "MM_CH4", "kind": "variable", "doc": "<p>Molar mass of atmosphere avg (g/mol) (dry).</p>\n", "default_value": "16.043"}, {"fullname": "utility_constants.MM_ATM", "modulename": "utility_constants", "qualname": "MM_ATM", "kind": "variable", "doc": "<p>Surface area of Earth in m^2. Based on authalic radius, which is a spherical radius that gives same surface area \nas the reference ellipsoid, which is wgs84.</p>\n", "default_value": "28.965"}, {"fullname": "utility_constants.SURF_AREA", "modulename": "utility_constants", "qualname": "SURF_AREA", "kind": "variable", "doc": "<p>Dictionary between month number and name.</p>\n", "default_value": "510065592755264.56"}, {"fullname": "utility_constants.MONTH_NUM_TO_NAME", "modulename": "utility_constants", "qualname": "MONTH_NUM_TO_NAME", "kind": "variable", "doc": "<p></p>\n", "default_value": "{1: &#x27;January&#x27;, 2: &#x27;February&#x27;, 3: &#x27;March&#x27;, 4: &#x27;April&#x27;, 5: &#x27;May&#x27;, 6: &#x27;June&#x27;, 7: &#x27;July&#x27;, 8: &#x27;August&#x27;, 9: &#x27;September&#x27;, 10: &#x27;October&#x27;, 11: &#x27;November&#x27;, 12: &#x27;December&#x27;}"}, {"fullname": "utility_dataframes", "modulename": "utility_dataframes", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "utility_dataframes.clean_up_dataframe", "modulename": "utility_dataframes", "qualname": "clean_up_dataframe", "kind": "function", "doc": "<p>Cleans up a Pandas DataFrame from junk columns that contain only NaN values and returns this cleaned-up DataFrame.\nThe junk columns may be a result of pd.read_fwf() separating out a single column with a long label into two columns where the second column \ncontains the junk values. For example, the column \"rho A+B+C (g/cm^3)\" may get separated to \"rho A+B+C\" and \"(g/cm^3)\", in which the latter\ncolumn, which will contain only NaN entries, should be deleted.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df:</strong>  DataFrame to be cleaned.</li>\n<li><strong>print_to_console:</strong>  Indicates if the contents of the data should be printed to the console to monitor the progress.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>df: DataFrame after cleaning operations have been applied.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">print_to_console</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_dataframes.get_columns_without_units_in_dataframe", "modulename": "utility_dataframes", "qualname": "get_columns_without_units_in_dataframe", "kind": "function", "doc": "<p>Returns all column names in a Pandas DataFrame without the units. For example, return 'Mass' if the colum name is 'Mass (kg)'.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df:</strong>  The input DataFrame.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A list of all column names, with the units removed.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_dataframes.get_matching_column_in_dataframe", "modulename": "utility_dataframes", "qualname": "get_matching_column_in_dataframe", "kind": "function", "doc": "<p>Returns the column name(s) in a Pandas DataFrame that matches the variable.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df:</strong>  The input DataFrame.</li>\n<li><strong>variable:</strong>  Variable name to search for in the column names.</li>\n<li><strong>all_matches:</strong>  If True, all columns that matches the variable will be returned. If False, only the first matching column will be returned.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The matching column name(s), or None if no match is found.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">variable</span>, </span><span class=\"param\"><span class=\"n\">all_matches</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_dataframes.move_columns_next_to_each_other_in_dataframe", "modulename": "utility_dataframes", "qualname": "move_columns_next_to_each_other_in_dataframe", "kind": "function", "doc": "<p>Rearranges a Pandas DataFrame by moving column2 next to column1.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>column1:</strong>  Column next to which column2 will be moved. The order of all columns prior to column1 will be unaffected.</li>\n<li><strong>column2:</strong>  Column to move next to column1.</li>\n<li><strong>df:</strong>  DataFrame whose columns will be rearranged.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new DataFrame with column1 and column2 moved next to each other.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">column1</span>, </span><span class=\"param\"><span class=\"n\">column2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_dataframes.perform_ttest", "modulename": "utility_dataframes", "qualname": "perform_ttest", "kind": "function", "doc": "<p>Performs a t-test for the means of two (presumed) independent data sets.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df:</strong>  Pandas DataFrame containing the columns for both data sets.</li>\n<li><strong>columns_set_1:</strong>  List of columns in the DataFrame for the first data set.</li>\n<li><strong>columsn_set_2:</strong>  List of columns in the DataFrame for the second data set.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The p-value produced by the t-test.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">columns_set_1</span>, </span><span class=\"param\"><span class=\"n\">columns_set_2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_dataframes.read_file_into_dataframe", "modulename": "utility_dataframes", "qualname": "read_file_into_dataframe", "kind": "function", "doc": "<p>Reads a csv or fixed-width-format file, puts the contents into a Pandas DataFrame, and returns the DataFrame.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>file_name:</strong>  Complete path and name of the output file.</li>\n<li><strong>clean_up_df:</strong>  Boolean that specifies if we want to call clean_up_dataframe() on the DataFrame before returning it.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame containing the contents of the file.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_name</span>, </span><span class=\"param\"><span class=\"n\">clean_up_df</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_dataframes.write_data_and_labels_to_csv", "modulename": "utility_dataframes", "qualname": "write_data_and_labels_to_csv", "kind": "function", "doc": "<p>Stores the given data and column labels in a Pandas DataFrame and writes the contents of the DataFrame to a csv file.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>file_name:</strong>  Complete path and name of the output file.</li>\n<li><strong>data:</strong>  Contains one or more columns of data.</li>\n<li><strong>column_labels:</strong>  List of strings representing the column labels.</li>\n<li><strong>transpose_data:</strong>  Indicates if it is necessary to transpose the data (which it would be if the data are stored in a list of lists, for example)\nso that the data appear along the columns of the output file rather along the rows.</li>\n<li><strong>keep_index_column:</strong>  Specifies whether to print the index column in the output file.</li>\n<li><strong>keep_header:</strong>  Indicates if the output file should contain headers for column labels.</li>\n<li><strong>separation:</strong>  Indicates the character(s) to be used as column separators.</li>\n<li><strong>format:</strong>  Format for floats in the output file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">file_name</span>,</span><span class=\"param\">\t<span class=\"n\">data</span>,</span><span class=\"param\">\t<span class=\"n\">column_labels</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">transpose_data</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">keep_index_column</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">keep_header</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">separation</span><span class=\"o\">=</span><span class=\"s1\">&#39;,&#39;</span>,</span><span class=\"param\">\t<span class=\"nb\">format</span><span class=\"o\">=</span><span class=\"s1\">&#39;</span><span class=\"si\">%12.8e</span><span class=\"s1\">&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_dataframes.write_data_and_labels_to_fwf", "modulename": "utility_dataframes", "qualname": "write_data_and_labels_to_fwf", "kind": "function", "doc": "<p>Stores the given data and column labels in a Pandas DataFrame and writes the contents of the DataFrame to an output file in fixed-width format.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>file_name:</strong>  Complete path and name of the output file.</li>\n<li><strong>data:</strong>  Contains one or more columns of data.</li>\n<li><strong>column_labels:</strong>  List of strings representing the column labels.</li>\n<li><strong>transpose_data:</strong>  Indicates if it is necessary to transpose the data (which it would be if the data are stored in a list of lists, for example)\nso that the data appear along the columns of the output file rather along the rows.</li>\n<li><strong>keep_index_column:</strong>  Specifies whether to print the index column in the output file.</li>\n<li><strong>print_to_console:</strong>  Indicates if the contents of the data should be printed to the console.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">file_name</span>,</span><span class=\"param\">\t<span class=\"n\">data</span>,</span><span class=\"param\">\t<span class=\"n\">column_labels</span>,</span><span class=\"param\">\t<span class=\"n\">transpose_data</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">keep_index_column</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">print_to_console</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_dataframes.write_dataframe_to_fwf", "modulename": "utility_dataframes", "qualname": "write_dataframe_to_fwf", "kind": "function", "doc": "<p>Writes the contents of a Pandas DataFrame to an output file in fixed-width format (fwf), omitting the index column if specified to do so.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>file_name:</strong>  Complete path and name of the output file.</li>\n<li><strong>df:</strong>  DataFrame in which the data to be written to the output file are stored.</li>\n<li><strong>keep_index_column:</strong>  Specifies whether to print the index column in the output file.</li>\n<li><strong>width_index_column:</strong>  Specifies the number of characters that span the width of the index column.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_name</span>, </span><span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">keep_index_column</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">width_index_column</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_E3SM_netcdf", "modulename": "utility_E3SM_netcdf", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "utility_E3SM_netcdf.extract_year_and_month_from_name_of_netcdf_file", "modulename": "utility_E3SM_netcdf", "qualname": "extract_year_and_month_from_name_of_netcdf_file", "kind": "function", "doc": "<p>Finds the year and month from the name of a given E3SM-generated NetCDF file.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>file:</strong>  NetCDF file containing data for one month in a particular year.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The year and month indicated in the name of the NetCDF file.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_E3SM_netcdf.find_gridcell_areas_in_netcdf_file", "modulename": "utility_E3SM_netcdf", "qualname": "find_gridcell_areas_in_netcdf_file", "kind": "function", "doc": "<p>Obtains the grid cell areas of all latitude/longitude coordinates in an E3SM-generated (EAM or ELM or EHC) NetCDF file.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>file:</strong>  NetCDF file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>NumPy array containing the grid cell areas of all coordinates in units of m^2 and an xarray Dataset containing data from the file.\n  Also returns the land and non-land (which is defined as ocean if in the case of EAM) fractions.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_E3SM_netcdf.get_netcdf_files_between_start_and_end_years", "modulename": "utility_E3SM_netcdf", "qualname": "get_netcdf_files_between_start_and_end_years", "kind": "function", "doc": "<p>Finds all E3SM-generated NetCDF files in a given list that fall between the start and end years.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>files:</strong>  List of NetCDF files.</li>\n<li><strong>start_year:</strong>  Start year.</li>\n<li><strong>end_year:</strong>  End year.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>List containing the NetCDF files that fall between the start and end years.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">files</span>, </span><span class=\"param\"><span class=\"n\">start_year</span>, </span><span class=\"param\"><span class=\"n\">end_year</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_functions", "modulename": "utility_functions", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "utility_functions.add_lists_elementwise", "modulename": "utility_functions", "qualname": "add_lists_elementwise", "kind": "function", "doc": "<p>Performs elementwise addition of two lists.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>list1:</strong>  The first list.</li>\n<li><strong>list2:</strong>  The second list.</li>\n<li><strong>list2_are_units:</strong>  Boolean that specifies whether list2 represents the units corresponding to list1. This would be useful when forming \ncolumn headers, where list1 specifies the quantities and list2 specifies the corresponding units for those quantities.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new list containing the element-wise sums of list1 and list2. If list2_are_units is True, then the elements of list2 will be in parentheses \n  so that each element of the combined list will be of the form 'a (b)', where a is from list1 and b is from list2.\n  Returns None if the lists are not of the same length.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">list1</span>, </span><span class=\"param\"><span class=\"n\">list2</span>, </span><span class=\"param\"><span class=\"n\">list2_are_units</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_functions.check_is_list_of_lists", "modulename": "utility_functions", "qualname": "check_is_list_of_lists", "kind": "function", "doc": "<p>Checks if the given iterable is a list of lists.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data:</strong>  Iterable we want to check is a list of lists.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>True if data is a list of lists, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_functions.check_substrings_in_list", "modulename": "utility_functions", "qualname": "check_substrings_in_list", "kind": "function", "doc": "<p>Checks if either all or any of the elements of the substrings list are substrings of at least one element in list.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>substring:</strong>  A list of strings (substrings to search for).</li>\n<li><strong>list:</strong>  A list of strings (strings to search within).</li>\n<li><strong>all_or_any:</strong>  String whose value should be either 'all' or 'any'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>True if either all or any of the elements of substrings are substrings of at least one element in list, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">substrings</span>, </span><span class=\"param\"><span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">all_or_any</span><span class=\"o\">=</span><span class=\"s1\">&#39;all&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_functions.check_substrings_in_string", "modulename": "utility_functions", "qualname": "check_substrings_in_string", "kind": "function", "doc": "<p>Checks if either all or any of the elements of the substrings list are substrings of the string.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>substring:</strong>  A list of strings (substrings to search for).</li>\n<li><strong>string:</strong>  String to search within.</li>\n<li><strong>all_or_any:</strong>  String whose value should be either 'all' or 'any'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>True if either all or any of the elements of substrings are substrings of the string, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">substrings</span>, </span><span class=\"param\"><span class=\"n\">string</span>, </span><span class=\"param\"><span class=\"n\">all_or_any</span><span class=\"o\">=</span><span class=\"s1\">&#39;all&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_functions.convert_month_numbers_to_", "modulename": "utility_functions", "qualname": "convert_month_numbers_to_", "kind": "function", "doc": "<p>Checks if either all or any of the elements of the substrings list are substrings of the string.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>substring:</strong>  A list of strings (substrings to search for).</li>\n<li><strong>string:</strong>  String to search within.</li>\n<li><strong>all_or_any:</strong>  String whose value should be either 'all' or 'any'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>True if either all or any of the elements of substrings are substrings of the string, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">substrings</span>, </span><span class=\"param\"><span class=\"n\">string</span>, </span><span class=\"param\"><span class=\"n\">all_or_any</span><span class=\"o\">=</span><span class=\"s1\">&#39;all&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_functions.create_numpy_array_from_ds", "modulename": "utility_functions", "qualname": "create_numpy_array_from_ds", "kind": "function", "doc": "<p>Creates a list of NumPy arrays from the specified variables of an xarray Dataset. </p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>ds:</strong>  xarray Dataset.</li>\n<li><strong>variables:</strong>  List of variables.</li>\n<li><strong>fill_nan_values:</strong>  List that indicates what to set NaN values to for each variable.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>List of arrays, one for each ds variable. If only one variable is specified, then a single array (not a list with this array) is returned.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ds</span>, </span><span class=\"param\"><span class=\"n\">variables</span>, </span><span class=\"param\"><span class=\"n\">fill_nan_values</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_functions.get_all_files_in_path", "modulename": "utility_functions", "qualname": "get_all_files_in_path", "kind": "function", "doc": "<p>Gets a list of complete paths for all files that are in a particular directory.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>path:</strong>  Path of directory where we want to search for files.</li>\n<li><strong>file_name_substrings:</strong>  A list of all substrings that must be in the file names.</li>\n<li><strong>file_extension:</strong>  File extension that should be in all files. </li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A list with complete paths to all files in the directory. \n  If both file_name_substrings and file_extension are None, then all files in the directory will be included in the list.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span>, </span><span class=\"param\"><span class=\"n\">file_name_substrings</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">file_extension</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_functions.modify_list_based_on_condition", "modulename": "utility_functions", "qualname": "modify_list_based_on_condition", "kind": "function", "doc": "<p>Modifies a list by applying a condition and a function to generate new values.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>original_list:</strong>  The list to be modified.</li>\n<li><strong>condition:</strong>  A function that takes an element as input and returns True if the condition is met, and False otherwise.</li>\n<li><strong>new_value_function:</strong>  A function that takes an element as input and returns the new value to replace the original element.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new list with the modified elements.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">original_list</span>, </span><span class=\"param\"><span class=\"n\">condition</span>, </span><span class=\"param\"><span class=\"n\">new_value_function</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_functions.print_p_values", "modulename": "utility_functions", "qualname": "print_p_values", "kind": "function", "doc": "<p>Prints the p-values from a t-test to the console and optionally prints to an output file.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>ttest:</strong>  t-test object.</li>\n<li><strong>variable:</strong>  Variable for which the t-test was performed.</li>\n<li><strong>p_value_threshold:</strong>  Threshold for the p-value. The message to the console will indicate if the p-value falls below this threshold.</li>\n<li><strong>p_value_file:</strong>  Path and name for the file where the p-value result will be printed.</li>\n<li><strong>output_file_or_label:</strong>  Output file or label from where the data used to perform the t-test were obtained.</li>\n<li><strong>p_value_file_print_only_if_below_threshold:</strong>  If true, the p-value gets printed to the file only if it falls below the threshold.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ttest</span>,</span><span class=\"param\">\t<span class=\"n\">variable</span>,</span><span class=\"param\">\t<span class=\"n\">p_value_threshold</span>,</span><span class=\"param\">\t<span class=\"n\">p_value_file</span>,</span><span class=\"param\">\t<span class=\"n\">output_file_or_label</span>,</span><span class=\"param\">\t<span class=\"n\">p_value_file_print_only_if_below_threshold</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_functions.replace_inside_parentheses", "modulename": "utility_functions", "qualname": "replace_inside_parentheses", "kind": "function", "doc": "<p>Replaces the string inside parentheses with a given replacement string.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>text:</strong>  The input string.</li>\n<li><strong>replacement:</strong>  The string with which we will replace the content inside parentheses.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The modified string with the content inside parentheses replaced.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">text</span>, </span><span class=\"param\"><span class=\"n\">replacement</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_functions.sort_file", "modulename": "utility_functions", "qualname": "sort_file", "kind": "function", "doc": "<p>Sorts the lines of a file alphabetically.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>file_path:</strong>  The file to be sorted.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_plots", "modulename": "utility_plots", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "utility_plots.width_default", "modulename": "utility_plots", "qualname": "width_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "10"}, {"fullname": "utility_plots.height_default", "modulename": "utility_plots", "qualname": "height_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "8"}, {"fullname": "utility_plots.scale_default", "modulename": "utility_plots", "qualname": "scale_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;linear&#x27;"}, {"fullname": "utility_plots.axis_limits_default", "modulename": "utility_plots", "qualname": "axis_limits_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "None"}, {"fullname": "utility_plots.num_contour_levels_default", "modulename": "utility_plots", "qualname": "num_contour_levels_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "20"}, {"fullname": "utility_plots.axis_label_size_default", "modulename": "utility_plots", "qualname": "axis_label_size_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "24"}, {"fullname": "utility_plots.tick_label_size_default", "modulename": "utility_plots", "qualname": "tick_label_size_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "20"}, {"fullname": "utility_plots.legend_label_size_default", "modulename": "utility_plots", "qualname": "legend_label_size_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "14"}, {"fullname": "utility_plots.legend_on_default", "modulename": "utility_plots", "qualname": "legend_on_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "True"}, {"fullname": "utility_plots.linewidth_default", "modulename": "utility_plots", "qualname": "linewidth_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "2"}, {"fullname": "utility_plots.produce_png_default", "modulename": "utility_plots", "qualname": "produce_png_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "False"}, {"fullname": "utility_plots.use_latex_default", "modulename": "utility_plots", "qualname": "use_latex_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "False"}, {"fullname": "utility_plots.bbox_inches_default", "modulename": "utility_plots", "qualname": "bbox_inches_default", "kind": "variable", "doc": "<p>Hex codes of Matplotlib Tableau color palette: blue, orange, green, red, purple, brown, pink, gray, olive, cyan.</p>\n", "default_value": "None"}, {"fullname": "utility_plots.plot_colors_default", "modulename": "utility_plots", "qualname": "plot_colors_default", "kind": "variable", "doc": "<p>Tuples for different line styles in plots.</p>\n", "default_value": "[&#x27;#1f77b4&#x27;, &#x27;#ff7f0e&#x27;, &#x27;#2ca02c&#x27;, &#x27;#d62728&#x27;, &#x27;#9467bd&#x27;, &#x27;#8c564b&#x27;, &#x27;#e377c2&#x27;, &#x27;#7f7f7f&#x27;, &#x27;#bcbd22&#x27;, &#x27;#17becf&#x27;]"}, {"fullname": "utility_plots.linestyle_tuples_default", "modulename": "utility_plots", "qualname": "linestyle_tuples_default", "kind": "variable", "doc": "<p></p>\n", "default_value": "[(&#x27;solid&#x27;, (0, ())), (&#x27;dashed&#x27;, (0, (5, 5))), (&#x27;dotted&#x27;, (0, (1, 5))), (&#x27;dashdot&#x27;, (0, (3, 5, 1, 5))), (&#x27;loosely dotted&#x27;, (0, (1, 10))), (&#x27;loosely dashed&#x27;, (0, (5, 10))), (&#x27;densely dashed&#x27;, (0, (5, 1))), (&#x27;loosely dashdotted&#x27;, (0, (3, 10, 1, 10))), (&#x27;densely dashdotted&#x27;, (0, (3, 1, 1, 1))), (&#x27;dashdotdotted&#x27;, (0, (3, 5, 1, 5, 1, 5))), (&#x27;loosely dashdotdotted&#x27;, (0, (3, 10, 1, 10, 1, 10))), (&#x27;densely dashdotdotted&#x27;, (0, (3, 1, 1, 1, 1, 1)))]"}, {"fullname": "utility_plots.create_contour_plot", "modulename": "utility_plots", "qualname": "create_contour_plot", "kind": "function", "doc": "<p>Creates a contour plot.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x:</strong>  NumPy array or list containing the quantity to plot on the x axis.</li>\n<li><strong>y:</strong>  NumPy array or list containing the quantity to plot on the y axis.</li>\n<li><strong>z:</strong>  NumPy array or list containing the quantity to plot on the z axis.</li>\n<li><strong>options:</strong>  Dictionary that contains plotting options like number of contour levels or colorbar labels.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">z</span>, </span><span class=\"param\"><span class=\"n\">options</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_plots.save_figure", "modulename": "utility_plots", "qualname": "save_figure", "kind": "function", "doc": "<p>Saves a figure as either a .pdf (default) or .png (if figure name ends with .png or if produce_png in the options dictionary is True).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>name:</strong>  Name of the figure.</li>\n<li><strong>fig:</strong>  Object for the figure of interest.</li>\n<li><strong>options:</strong>  Dictionary that contains plotting options, including the value of produce_png.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name</span>, </span><span class=\"param\"><span class=\"n\">fig</span>, </span><span class=\"param\"><span class=\"n\">options</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_plots.set_figure_options", "modulename": "utility_plots", "qualname": "set_figure_options", "kind": "function", "doc": "<p>Sets options when creating a figure.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>fig:</strong>  Object for the figure of interest.</li>\n<li><strong>ax:</strong>  Axes object corresponding to the figure of interest. </li>\n<li><strong>options:</strong>  Dictionary that contains plotting options like x and y labels, the name of the figure, etc.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>N/A.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fig</span>, </span><span class=\"param\"><span class=\"n\">ax</span>, </span><span class=\"param\"><span class=\"n\">options</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_xarray", "modulename": "utility_xarray", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "utility_xarray.calculate_mean_and_std_of_da_list", "modulename": "utility_xarray", "qualname": "calculate_mean_and_std_of_da_list", "kind": "function", "doc": "<p>Calculates the mean of a list of xarray DataArrays and optionally also the standard deviation of this list.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>da_list:</strong>  A list of DataArrays with the same dimensions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A DataArray containing the mean of the input DataArrays and optionally also the standard deviation of this list.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">da_list</span>, </span><span class=\"param\"><span class=\"n\">calculate_std</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_xarray.calculate_statistics_of_xarray", "modulename": "utility_xarray", "qualname": "calculate_statistics_of_xarray", "kind": "function", "doc": "<p>Calculates the min, mean, median, max, and the standard deviation of an xarray or uxarray object (DataArray, Dataset, or uxarray data structure).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data:</strong>  Object of type xarray or uxarray whose statistical properties we want to calculate.</li>\n<li><strong>variable:</strong>  Variable of interest, used in the case of an xarray Dataset or uxarray data structure (UxDataArray or UxDataset).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>min, mean, median, max, and standard deviation of the xarray or uxarray object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">variable</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utility_xarray.convert_xarray_to_uxarray", "modulename": "utility_xarray", "qualname": "convert_xarray_to_uxarray", "kind": "function", "doc": "<p>Converts an xarray object (DataArray or Dataset) into an uxarray object (UxDataArray or UxDataset).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data:</strong>  Object of type xarray.</li>\n<li><strong>grid:</strong>  Grid object for the unstructured grid contained within the uxarray object.</li>\n<li><strong>variable:</strong>  Variable of interest.</li>\n<li><strong>fill_value:</strong>  Value to fill NaNs.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>uxarray (UxDataArray or UxDataset) version of the given xarray object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">grid</span>, </span><span class=\"param\"><span class=\"n\">variable</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">fillna</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();